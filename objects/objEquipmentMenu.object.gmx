<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprEquipMenuBG</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2002</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = false;

phase = 0;

option = 1;
optReturn = 1;

sortOption = 0; //todo: sort menu w/ shoulder button
sortOptionMemory = 0;
sortMode = false;

scrollOffset = 0;
offsetTimer = 0;

animTimer = 0;
bgTimer = choose(0, 360, 720, 1080);
quickScrollTimer = 25;
extremeSpeedTimer = 400;

quickExit = false;

//cost of equipment piece, by image
equipmentCosts = makeArray(3, 8, 3, 0, 6, 5, 12, 12, 4, 4, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
for(var q = 0; q &lt; array_length_1d(equipmentCosts); q++)
{
    accessoryInfoFetch(q);
    equipmentNames[q] = accName;
}

ownedCount = array_length_1d(global.equipmentOwned);
shownAtOnce = min(8, ownedCount);

//BP used is only really relevant in this menu, so it's calculated on the spot instead of stored
bpUsed = 0;
for(var q = 0; q &lt; sprite_get_number(sprEquipmentIcons); q++)
    bpUsed += equipmentCosts[q] * (global.equipmentActive[q] != 0);

bpOwned = 229; //since this is a collectible, it's gonna have to be made a global var no matter what

bpHundreds = 1; //todo: auto-calculate these
bpTens = 11;
bpOnes = 19;
coinsTotal = bpHundreds + bpTens + bpOnes;
bpHeights = allocateArray(coinsTotal, 0);
bpAnim = allocateArray(coinsTotal, 0);
bpAnimDest = allocateArray(coinsTotal, 0);

badgesListX = 88;
badgesListY = 16;
badgesListW = 146;
badgesListH = 142;
badgesDescX = 88;
badgesDescY = 192;
bpTallyX = 24;
bpTallyY = 40;
showModeX = 24;
showModeY = 8;
sortMenuX = 88;
sortMenuY = 5;

badgeListSurface = surface_create(badgesListW, badgesListH);

//correct the flippy coin display
var pts = bpUsed;
var denom = 100;
for (var c = 0; c &lt; coinsTotal; c++)
{
    if c = bpHundreds
        denom = 10;
    else if c = bpTens
        denom = 1;
    
    if pts &gt;= denom
    {
        pts -= denom;
        bpAnimDest[c] = true;
        bpAnim[c] = bpAnimDest[c] * 4;
    }
    else
        bpAnimDest[c] = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clear surface
if surface_exists(badgeListSurface)
    surface_free(badgeListSurface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///transitions &amp; option switching

switch (phase)  //copied from pause menu
{
    // Fading out
    case 0:
        if (objGlobalControl.fadeAlpha == 1)
        {
            global.nextRoom = 0;
            objGlobalControl.showhealth = 0;
            visible = true;
            phase++;
        }
        break;
    
    // Fading in
    case 1:
        if (objGlobalControl.fadeAlpha == 0)
            phase++;
        break;
    
    // Doing menu selections
    case 2:
        //exit menu with shoot button
        if global.keyShootPressed[0]
        {
            quickExit = true;
            break;
        }
        
        //sort menu functions
        if global.keyWeaponSwitchLeft[0]
        {
            if sortMode = false
            {
                playSFX(sfxPause);
                sortMode = true;
            }
        }
        else if sortMode
        {
            playSFX(sfxMenuSelect);
            event_user(0);
            sortMode = false;
            sortOptionMemory = sortOption;
        }
        
        var xDir = (global.keyRightPressed[0] - global.keyLeftPressed[0]);
        var yDir = (global.keyDown[0] - global.keyUp[0]);
        
        if !sortMode
        {   //out of sort menu
            //horizontal is between exit confirmation and list of badges
            if (xDir != 0)
            {
                playSFX(sfxWeaponSwitch);
                if option == 0
                    option = optReturn;
                else
                    option = 0;
            }
            
            //scroll &amp; quickscroll
            var doScroll = false;
            if option != 0 &amp;&amp; yDir != 0
            {   //quickscrolling
                if extremeSpeedTimer-- &lt;= 0
                {
                    if extremeSpeedTimer mod 2 = 0
                        doScroll = true;
                }
                else if (quickScrollTimer-- == 25) || (quickScrollTimer == 0)
                {
                    doScroll = true;
                    if (quickScrollTimer == 0)
                    {
                        if extremeSpeedTimer &lt; 100
                            quickScrollTimer = 4;
                        else
                            quickScrollTimer = 7;
                    }
                }
            }
            else
            {
                quickScrollTimer = 25;
                extremeSpeedTimer = 600;
            }
            
            //change the selected option
            if (doScroll)
            {   
                option += yDir;
                if option &lt;= 0
                    option = ownedCount;
                if option &gt;= ownedCount + 1
                    option = 1;
                optReturn = option;
                //different offset based on the direction you scroll in
                if yDir &lt; 0
                    scrollOffset = clamp((option) - 4, 0, ownedCount - shownAtOnce);
                else
                    scrollOffset = clamp((option) - 5, 0, ownedCount - shownAtOnce);
                //update description
                accessoryInfoFetch(global.equipmentOwned[option - 1]); 
                playSFX(sfxWeaponSwitch);
            }
        }
        else    //i.e. if sortMode
        {
            //change sort option
            if quickScrollTimer = 0 &amp;&amp; yDir != 0
            {
                sortOption += yDir;
                quickScrollTimer = 1;
                playSFX(sfxWeaponSwitch);
                
                if sortOption &lt; 0
                    sortOption = 4;
                if sortOption &gt; 4
                    sortOption = 0;
            }
            else if yDir == 0
                quickScrollTimer = 0;
        }
        break;
    
    // Fading out
    case 3:
        //if this is the dedicated test room, just return to room select
        if (room == rmEquipmentTest)
            global.nextRoom = rmRoomSelect;
        else
        {
            global.nextRoom = -1;
            if objGlobalControl.fadeAlpha == 1
            {
                global.nextRoom = 0;
                visible = false;
                phase++;
            }
        }
        break;
    
    // Fading back in to gameplay
    case 4:
        if objGlobalControl.fadeAlpha == 0
        {
            global.frozen = true;
            instance_destroy();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///actual option functions

if phase == 2 &amp;&amp; (global.keyJumpPressed[0] || global.keyPausePressed[0] || quickExit)
{
    //option 0 means 'done' i guess?
    //also using the b button procs this
    if option == 0 || quickExit
    {
        phase++;
        playSFX(sfxMenuSelect);
        //assign the "accessory hotbar"
        global.equipmentHotbar = makeArray();
        var index = 0;
        for(var b = 0; b &lt; ownedCount; b++)
        {
            if global.equipmentActive[global.equipmentOwned[b]]
                global.equipmentHotbar[index++] = global.equipmentOwned[b];
        }
    }
    else    //all options past that are acessories to toggle enabled
    {
        var thisItem = global.equipmentOwned[option - 1];
        var thisCost = equipmentCosts[thisItem];
        var cPrev = bpUsed;
        if !global.equipmentActive[thisItem]
        {
            //try to equip it if it's unequipped
            if bpUsed + thisCost &gt; bpOwned  //don't equip it if you don't have the points
                playSFX(sfxError);
            else
            {
                global.equipmentActive[thisItem] = true;
                bpUsed += thisCost;
                playSFX(sfxClamp);
            }
        }
        else
        {
            //unequip it if it's equipped
            global.equipmentActive[thisItem] = false;
            global.equipmentDisabled[thisItem] = false;
            bpUsed -= thisCost;
            if bpUsed &lt; 0
            {
                printErr("BP for current equipment was less than zero somehow!!!!");
                bpUsed = 0;
                playSFX(sfxDebugMenu);//this should catch your attention
            }
            playSFX(sfxClamp);
        }
        //update coin display if bp used was changed
        if cPrev != bpUsed
        {
            var pts = bpUsed;
            var denom = 100;
            for (var c = 0; c &lt; coinsTotal; c++)
            {
                if c = bpHundreds
                    denom = 10;
                else if c = bpTens
                    denom = 1;
                
                if pts &gt;= denom
                {
                    pts -= denom;
                    bpAnimDest[c] = true;
                }
                else
                    bpAnimDest[c] = false;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///animations

animTimer++;

//smoothly scrolling badge list
if (abs(scrollOffset - offsetTimer) &lt; 0.05 || offsetTimer &lt; 0)
    offsetTimer = scrollOffset;
offsetTimer += (scrollOffset - offsetTimer) / 8;

//flipping coins
var denom = 100;
for (var c = 0; c &lt; coinsTotal; c++)
{
    //account for different denominations
    if c = bpHundreds
        denom = 10;
    else if c = bpTens
        denom = 1;
    
    //
    switch(denom)
    {
        case 100:   //bpAnimDest[c]
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.25;
                bpHeights[c] = min(12, bpHeights[c] + 2);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 4);
            break;
        case 10:
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.5;
                bpHeights[c] = min(6, bpHeights[c] + 1);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 2);
            break;
        case 1:
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.5;
                bpHeights[c] = min(4, bpHeights[c] + 0.5);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 1);
            break;
    }
    if bpAnim[c] &gt;= 8
        bpAnim[c] -= 8;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///sorting code

//determine sorting criteria
var sortArr;
switch(sortOption)
{
    case 0: //BP cost (first, ID second)
        for (var p = 0; p &lt; ownedCount; p++)
            sortArr[p] = ((equipmentCosts[global.equipmentOwned[p]] + 5) * 1000) + global.equipmentOwned[p];
        // this is to keep the ordering 100% consistent,
        // even though some items will have identical BP costs
        break;
    
    case 1: //name
        for (var p = 0; p &lt; ownedCount; p++)
            sortArr[p] = equipmentNames[global.equipmentOwned[p]];
        break;
    
    case 2: //ID
        for (var p = 0; p &lt; ownedCount; p++)
            sortArr[p] = global.equipmentOwned[p];
        break;
    
    case 3: //active (first, existing sort second)
        for (var p = 0; p &lt; ownedCount; p++)
            sortArr[p] = ((!global.equipmentActive[global.equipmentOwned[p]] + 5) * 1000) + p;
        break;
    
    case 4: //random
        for (var p = 0; p &lt; ownedCount; p++)
            sortArr[p] = random(100);
        break;
}
//sort list
quickSortBy(global.equipmentOwned, sortArr);

//update description
accessoryInfoFetch(global.equipmentOwned[option - 1]); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clear surface (defers to destroy event)
event_perform(ev_destroy, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);

// center display on non-standard resolutions
drawXPosition = view_xview[0] + view_wview[0] / 2 - 128;
drawYPosition = view_yview[0] + view_hview[0] / 2 - 112;

//cool backing
bgTimer += 0.25;
var sx = abs((bgTimer mod 1440) - 720);
var sy = abs(((bgTimer + 360) mod 1440) - 720);
for(var i = (sy mod 120) - 120; i &lt;= view_hview; i += 120)
{
    for(var j = (sx mod 120) - 120; j &lt;= view_wview; j += 120)
    {
        draw_background(bgArcadeCarpet, view_xview + j, view_yview + i);
    }
}

// draw menu bg
draw_sprite(sprite_index, 0, drawXPosition, drawYPosition);

//exit button
draw_sprite(sprExit, option == 0, drawXPosition + 40, drawYPosition + 16);

draw_set_halign(fa_left);
draw_set_valign(fa_top);

//--------------------------------------------

//badge list
//assign surface
if !surface_exists(badgeListSurface)
    badgeListSurface = surface_create(badgesListW, badgesListH);
surface_set_target(badgeListSurface);


//clear surface (or do speed effect for speedmode)
if extremeSpeedTimer &gt; 0
    draw_clear_alpha(c_black, 0);
else
{
    draw_set_alpha(0.05);
    draw_rectangle_colour(0, 0, badgesListW, badgesListH, c_black, c_black, c_black, c_black, false);
    draw_set_alpha(1);
}
//draw list to surface
var yOff = -round((offsetTimer mod 1) * 18);
for (i = max(0, floor(offsetTimer)); i &lt;= min(ceil(offsetTimer) + shownAtOnce + -1, ownedCount - 1); i++)
{
    draw_sprite(sprEquipmentIcons, global.equipmentOwned[i], 0, yOff);
    
    //non-selected options are darkened
    if (i != option - 1)
        draw_set_color(global.nesPalette[0]);
    
    draw_text(18, yOff, equipmentNames[global.equipmentOwned[i]]);
    draw_text(18, yOff + 8, string(equipmentCosts[global.equipmentOwned[i]]) + " BP");
    draw_set_color(c_white);
    if global.equipmentActive[global.equipmentOwned[i]]
        draw_text(badgesListW - 12, yOff + 8, "*");
    yOff += 18;
}

//draw surface to game
surface_reset_target();
draw_surface(badgeListSurface, badgesListX, badgesListY);

//list header
draw_text(128, 5, "EQUIPMENT");

//--------------------------------------------

//BP used
//text
draw_text(bpTallyX, bpTallyY, "BP use#" + string(bpUsed) + "#/" + string(bpOwned));

//flippy coins
var coinImg = sprEquipCoin100;
var dy = bpTallyY + 32;
var dx = 0;
for (var c = 0; c &lt; coinsTotal; c++)
{
    //handle decreases in denomination
    var sh = sprite_get_height(coinImg);
    if c == bpHundreds
    {
        coinImg = sprEquipCoin10;
        if dx != 0
        {
            dy += sh;
            dx = 0;
        }
        sh = sprite_get_height(coinImg);
    }
    if c == bpHundreds + bpTens
    {
        coinImg = sprEquipCoin;
        if dx != 0
        {
            dy += sh;
            dx = 0;
        }
        sh = sprite_get_height(coinImg);
    }
    
    //draw a coin
    draw_sprite(coinImg, bpAnim[c], dx + bpTallyX, dy - bpHeights[c]);
    dx += sh;   //coins should be symmetrical in both directions, right?
    //if next coin would go past border, move on to next line instead
    if dx + sh &gt; 48
    {
        dx = 0;
        dy += sh;
    }
}


//sort menu
if animTimer mod (32 * 2) &lt;= 32 || sortMode
    draw_sprite(sprEquipmentSortPrompt, 0, sortMenuX, sortMenuY);
if sortMode
    draw_sprite(sprEquipmentSortMenu, sortOption, sortMenuX, sortMenuY + 8);

//item description
draw_text(32, 176, accDesc);

// colored text overlays
if (global.showColoredTextOverlays)
{
    draw_sprite_ext(sprDot, 0, drawXPosition + 16, drawYPosition, view_wview[0] - 32, view_hview[0], 0,
        make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
        global.coloredTextOverlaysOpacity / 255);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
