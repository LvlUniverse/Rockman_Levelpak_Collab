<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprEquipMenuBG</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2002</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = false;

phase = 0;

option = 1;
sortOption = 0; //todo: sort menu w/ shoulder button

scrollOffset = 1;
offsetTimer = -1;

animTimer = 0;
quickScrollTimer = 25;
extremeSpeedTimer = 400;

//cost of equipment piece, by image
equipmentCosts = makeArray(3, 8, 3, 0, 6, 5, 12, 12);
equipmentNames = makeArray("Energy Balancer", "Energy Charger", "Energy Converter", "Normal Item", "Skull Amulet", "Met Helmet", "Energy Saver", "Super E.Balancer");
//whether the given equipment piece is active or not, by image. 
//needs to be a global variable later
equipmentActive = allocateArray(array_length_1d(equipmentCosts), false);

//the order the equipment is in in the menu. equipment you haven't bought won't appear
//needs to be a global variable later
equipmentOwned = makeArray(0, 1, 2, 4, 5, 6, 7, 1, 1, 1, 1, 2, 2, 1, 1, 4, 3, 1, 1, 1);
ownedCount = array_length_1d(equipmentOwned);
shownAtOnce = min(9, ownedCount);

bpUsed = 0; //only really relevant in this menu, so it may not need to be stored globally
bpOwned = 31; //since this is a collectible, it's gonna have to be made a global var no matter what

bpHundreds = 0; //todo: auto-calculate these
bpTens = 2;
bpOnes = 11;
coinsTotal = bpHundreds + bpTens + bpOnes;
bpHeights = allocateArray(coinsTotal, 0);
bpAnim = allocateArray(coinsTotal, 0);
bpAnimDest = allocateArray(coinsTotal, 0);

badgesListX = 88;
badgesListY = 16;
badgesListW = 146;
badgesListH = 160;
badgesDescX = 88;
badgesDescY = 192;
bpTallyX = 24;
bpTallyY = 56;
showModeX = 24;
showModeY = 8;
sortMenuX = 0;  //not implemented yet
sortMenuY = 0;

badgeListSurface = surface_create(badgesListW, badgesListH);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clear surface
if surface_exists(badgeListSurface)
    surface_free(badgeListSurface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///transitions &amp; option switching
animTimer++;

switch (phase)  //copied from pause menu
{
    // Fading out
    case 0:
        if (objGlobalControl.fadeAlpha == 1)
        {
            global.nextRoom = 0;
            objGlobalControl.showhealth = 0;
            visible = true;
            phase++;
        }
        break;
    
    // Fading in
    case 1:
        if (objGlobalControl.fadeAlpha == 0)
            phase++;
        break;
    
    // Doing menu selections
    case 2:
        //exit menu with shoot button
        if global.keyShootPressed[0]
        {
            phase++;
            playSFX(sfxMenuSelect);
            break;
        }
        
        var xDir = (global.keyRightPressed[0] - global.keyLeftPressed[0]);
        var yDir = (global.keyDown[0] - global.keyUp[0]);
        
        //horizontal is between exit confirmation and list of badges
        if (xDir != 0)
        {
            playSFX(sfxWeaponSwitch);
            option = !option;   //0 becomes 1, &gt;=1 becomes 0
        }
        
        //scrolling in the list of badges
        var doScroll = false;
        if option != 0 &amp;&amp; yDir != 0
        {   //quickscrolling
            if (extremeSpeedTimer-- &lt;= 0)
            {
                if extremeSpeedTimer mod 3 = 0
                    doScroll = true;
            }
            else if (quickScrollTimer-- == 25) || (quickScrollTimer == 0)
            {
                doScroll = true;
                if (quickScrollTimer == 0)
                    quickScrollTimer = 8;
            }
        }
        else
        {
            quickScrollTimer = 25;
            extremeSpeedTimer = 400;
        }
        if (doScroll)
        {   //change the selected option
            option += yDir;
            if option &lt;= 0
                option = ownedCount - 1;
            if option &gt;= ownedCount
                option = 1;
            playSFX(sfxWeaponSwitch);
        }
        break;
    
    // Fading out
    case 3:
        //if this is the dedicated test room, just return to room select
        if (room == rmEquipmentTest)
            global.nextRoom = rmRoomSelect;
        else
        {
            global.nextRoom = -1;
            if objGlobalControl.fadeAlpha == 1
            {
                global.nextRoom = 0;
                visible = false;
                phase++;
            }
        }
        break;
    
    // Fading back in to gameplay
    case 4:
        if objGlobalControl.fadeAlpha == 0
        {
            global.frozen = true;
            instance_destroy();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///actual option functions

if phase == 2 &amp;&amp; (global.keyJumpPressed[0] || global.keyPausePressed[0])
{
    //option 0 means 'done' i guess?
    if option == 0
    {
        phase++;
        playSFX(sfxMenuSelect);
    }
    else    //all options past that are acessories to toggle enabled
    {
        var thisItem = equipmentOwned[option];
        var thisCost = equipmentCosts[thisItem];
        var cPrev = bpUsed;
        if !equipmentActive[thisItem]
        {
            //try to equip it if it's unequipped
            if bpUsed + thisCost &gt; bpOwned  //don't equip it if you don't have the points
                playSFX(sfxError);
            else
            {
                equipmentActive[thisItem] = true;
                bpUsed += thisCost;
                playSFX(sfxClamp);
            }
        }
        else
        {
            //unequip it if it's equipped
            equipmentActive[thisItem] = false;
            bpUsed -= thisCost;
            if bpUsed &lt; 0
            {
                printErr("BP for current equipment was less than zero somehow!!!!");
                bpUsed = 0;
            }
            playSFX(sfxClamp);
        }
        //update coin display if bp used was changed
        if cPrev != bpUsed
        {
            var pts = bpUsed;
            var denom = 100;
            for (var c = 0; c &lt; coinsTotal; c++)
            {
                if c = bpHundreds
                    denom = 10;
                else if c = bpTens
                    denom = 1;
                
                if pts &gt;= denom
                {
                    pts -= denom;
                    bpAnimDest[c] = true;
                }
                else
                    bpAnimDest[c] = false;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///animations

//smoothly scrolling badge list
if (option != 0) &amp;&amp; (option &lt; ownedCount)
    scrollOffset = clamp((option) - floor(shownAtOnce * 0.5), 1, ownedCount - shownAtOnce);
if (abs(scrollOffset - offsetTimer) &lt; 0.05 || offsetTimer &lt; 0)
    offsetTimer = scrollOffset;
offsetTimer += (scrollOffset - offsetTimer) / 8;

//flipping coins
var denom = 100;
for (var c = 0; c &lt; coinsTotal; c++)
{
    //account for different denominations
    if c = bpHundreds
        denom = 10;
    else if c = bpTens
        denom = 1;
    
    //
    switch(denom)
    {
        case 100:   //bpAnimDest[c]
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.25;
                bpHeights[c] = min(12, bpHeights[c] + 2);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 4);
            break;
        case 10:
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.5;
                bpHeights[c] = min(6, bpHeights[c] + 1);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 2);
            break;
        case 1:
            if bpAnim[c] != bpAnimDest[c] * 4
            {
                bpAnim[c] += 0.5;
                bpHeights[c] = min(4, bpHeights[c] + 0.5);
            }
            else
                bpHeights[c] = max(0, bpHeights[c] - 1);
            break;
    }
    if bpAnim[c] &gt;= 8
        bpAnim[c] -= 8;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clear surface (defers to destroy event)
event_perform(ev_destroy, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);

// center display on non-standard resolutions
drawXPosition = view_xview[0] + view_wview[0] / 2 - 128;
drawYPosition = view_yview[0] + view_hview[0] / 2 - 112;

// draw menu bg
draw_sprite(sprite_index, 0, drawXPosition, drawYPosition);

draw_set_halign(fa_left);
draw_set_valign(fa_top);

//--------------------------------------------

//badge list
//assign surface
if !surface_exists(badgeListSurface)
    badgeListSurface = surface_create(badgesListW, badgesListH);
surface_set_target(badgeListSurface);


//draw list to surface
if extremeSpeedTimer &gt; 0
    draw_clear_alpha(c_black, 0);
else
{
    draw_set_alpha(0.05);
    draw_rectangle_colour(0, 0, badgesListW, badgesListH, c_black, c_black, c_black, c_black, false);
    draw_set_alpha(1);
}
var yOff = -round((offsetTimer mod 1) * 18);
for (i = max(1, floor(offsetTimer)); i &lt;= min(ceil(offsetTimer) + shownAtOnce + -1, ownedCount - 1); i++)
{
    draw_sprite(sprEquipmentIcons, equipmentOwned[i], 0, yOff);
    
    //non-selected options are darkened
    if (i != option)
        draw_set_color(global.nesPalette[0]);
    
    draw_text(18, yOff, equipmentNames[equipmentOwned[i]]);
    draw_text(18, yOff + 8, string(equipmentCosts[equipmentOwned[i]]) + " BP");
    draw_set_color(c_white);
    if equipmentActive[equipmentOwned[i]]
        draw_text(badgesListW - 12, yOff + 8, "*");
    yOff += 18;
}

//draw surface to game
surface_reset_target();
draw_surface(badgeListSurface, badgesListX, badgesListY);

//--------------------------------------------

//BP used
//text
draw_text(bpTallyX, bpTallyY, "BP use#" + string(bpUsed) + "#/" + string(bpOwned));

//flippy coins
var coinImg = sprEquipCoin100;
var dy = bpTallyY + 32;
var dx = 0;
for (var c = 0; c &lt; coinsTotal; c++)
{
    //handle decreases in denomination
    var sh = sprite_get_height(coinImg);
    if c == bpHundreds
    {
        coinImg = sprEquipCoin10;
        if dx != 0
        {
            dy += sh;
            dx = 0;
        }
        sh = sprite_get_height(coinImg);
    }
    if c == bpHundreds + bpTens
    {
        coinImg = sprEquipCoin;
        if dx != 0
        {
            dy += sh;
            dx = 0;
        }
        sh = sprite_get_height(coinImg);
    }
    
    //draw a coin
    draw_sprite(coinImg, bpAnim[c], dx + bpTallyX, dy - bpHeights[c]);
    dx += sh;   //coins should be symmetrical in both directions, right?
    //if next coin would go past border, move on to next line instead
    if dx + sh &gt; 48
    {
        dx = 0;
        dy += sh;
    }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
