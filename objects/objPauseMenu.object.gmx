<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPauseMenuBG</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = 0;

phase = 0; // 0: increasing the black rectangle's alpha

oldWeapon = global.weapon[0];
option = 10 + min(indexOf(global.weaponHotbar, oldWeapon), 11);
//oldOption = option;

wtank = 0;
mtank = 0;

confirm = false;

playerID = 0;
costumeID = 0;

// Stop charging
with (objMegaman)
{
    playerPalette();
}

//scrolling to a submenu is handled entirely by the submenu itself (for now?)
scrollX = 0;
scrollY = 0;
bgTimer = choose(0, 360, 720, 1080);

// set these here. makes everyone's lives easier.

etankPositionX = 56;   buttonPos[0, 0] = etankPositionX; 
etankPositionY = 16;    buttonPos[0, 1] = etankPositionY - 100; 
wtankPositionX = 76;   buttonPos[1, 0] = wtankPositionX;
wtankPositionY = 16;    buttonPos[1, 1] = wtankPositionY - 100;
mtankPositionX = 96;   buttonPos[2, 0] = mtankPositionX;
mtankPositionY = 16;    buttonPos[2, 1] = mtankPositionY - 100;  

optionsPositionX = 136; buttonPos[3, 0] = optionsPositionX + 8;
optionsPositionY = 208; buttonPos[3, 1] = optionsPositionY + 100;
checkPositionX = 152;   buttonPos[4, 0] = checkPositionX + 24;
checkPositionY = 208;   buttonPos[4, 1] = checkPositionY + 100;
exitPositionX = 200;    buttonPos[5, 0] = exitPositionX + 20;
exitPositionY = 208;    buttonPos[5, 1] = exitPositionY + 100;

rearrangePositionX = 16;    buttonPos[6, 0] = rearrangePositionX + 32;
rearrangePositionY = 208;    buttonPos[6, 1] = rearrangePositionY + 100;
infoPositionX = 80;    buttonPos[7, 0] = infoPositionX + 12;
infoPositionY = 208;    buttonPos[7, 1] = infoPositionY + 100;

//these buttons aren't anything. but, they could be!
buttonPos[8, 0] = undefined;
buttonPos[9, 0] = undefined;

//weapons at (38, 91), spaced 93x, 18y
for(var p = 0; p &lt;= 11; p++)
{
    buttonPos[p + 10, 0] = 32 + 28 + (floor(p / 6) * 104);
    buttonPos[p + 10, 1] = 56 + ((p mod 6) * 24);
}

rHeldWeapon = undefined;
rBusterResistance = 6;
//buster can be moved freely if it's already out of position
if global.weaponHotbar[0] != 0
    rBusterResistance = -22;

rCursorX = undefined;
rCursorY = undefined;
rCursorPriCol = undefined;
rCursorSecCol = undefined;

rCursorAnim = 0;
rAnimTime = 0;
rAnimatingOption = undefined;

rResetTimer = 0;

for(var q = 0; q &lt;= 11; q++)
{
    if global.weaponHotbar[q] == 0
        wepBarFills[q] = global.playerHealth[playerID];
    else if !global.weaponLocked[global.weaponHotbar[q]]
        wepBarFills[q] = global.ammo[playerID, global.weaponHotbar[q]];
    else
        wepBarFills[q] = 0;
}

//map menu hooks
useExit = false;
mapInfoFetch();

//options menu hooks
linkFade = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while a submenu is open
if (instance_exists(objOptionsMenu) || instance_exists(objDescriptionMenu)
    || instance_exists(objMapMenu) || instance_exists(objQuickAccessoryMenu))
{
    exit;
}

// do pause menu
switch (phase)
{
    // Fading out
    case 0:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1)
            {
                global.nextRoom = 0;
                other.visible = 1;
                other.phase = 1;
                showhealth = 0;
            }
        }
        break;
    
    // Fading in
    case 1:
        with (objGlobalControl)
        {
            if (fadeAlpha == 0)
            {
                other.phase = 2;
            }
        }
        event_user(0); // Moving the selection
        
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        //if b is pressed...
        if global.keyShootPressed[playerID]
        {
            if(confirm) //cancel confirm if confirming
                confirm = false;
            else
            {   //elsewise, leave weapon menu without switching weapons
                option = indexOf(global.weaponHotbar, oldWeapon) + 10;
                global.weapon[playerID] = oldWeapon;
                global.nextRoom = -1;
                phase = 3;
                playSFX(sfxSkullAmulet);
                exit;
            }
        }
        
        //swap to item menu with R button
        if global.keyWeaponSwitchRightPressed[0]
        {
            with(instance_create(x, y, objQuickAccessoryMenu))
                link = other;
            exit;
        }
        
        // Select the weapon/tank
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            event_user(1);
        
        break;
    
    // Fading out
    case 3:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1 &amp;&amp; global.nextRoom != 0)
            {
                showhealth = 1;
                with (other)
                {
                    if (global.weapon[playerID] != oldWeapon)
                    {
                        with (prtPlayerProjectile)
                        {
                            instance_destroy();
                        }
                    }
                    
                    global.nextRoom = 0;
                    visible = 0;
                }
            }
            else if (fadeAlpha == 0 &amp;&amp; global.nextRoom == 0)
            {
                with (other)
                {
                    audio_resume_all();
                    instance_destroy();
                    global.frozen = 0;
                }
            }
        }
        
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, global.weaponHotbar[option - 10]] &lt; 28)
                {
                    global.ammo[playerID, global.weaponHotbar[option - 10]] = min(28,
                        global.ammo[playerID, global.weaponHotbar[option - 10]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; array_length_1d(global.weaponHotbar); i++;)
                {
                    if (global.ammo[playerID, global.weaponHotbar[i]] &lt; 28)
                    {
                        global.ammo[playerID, global.weaponHotbar[i]] = min(28,
                            global.ammo[playerID, global.weaponHotbar[i]] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = indexOf(global.weaponHotbar, oldWeapon) + 10;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                else
                {
                    if global.wTanks &gt; 0
                        phase = 6;
                    else
                        option = 1;
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        //direct write to fills
        for(var q = 0; q &lt;= 11; q++)
        {
            if global.weaponHotbar[q] == 0
                wepBarFills[q] = global.playerHealth[playerID];
            else if !global.weaponLocked[global.weaponHotbar[q]]
                wepBarFills[q] = global.ammo[playerID, global.weaponHotbar[q]];
            else
                wepBarFills[q] = 0;
        }
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
        //quit from selection if player presses shoot
        if global.keyShootPressed[playerID]
        {
            option = 1;
            phase = 2;
        }
        else if (option &gt;= 10)
        {   //use tank if fire is pressed
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, global.weaponHotbar[option - 10]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                    global.wTanks -= 1;
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        
        break;
    
    case 7: //Rearrange weapons
        event_user(0);  //allow selection of weapons
        
        //if b is pressed and you're not holding a wep, exit rearrange mode
        if global.keyShootPressed[playerID] &amp;&amp; rHeldWeapon == undefined
        {
            phase = 2;
            playSFX(sfxMenuSelect);
            exit;
        }
        
        //hold L and R together for 1 second to reset weapon order to default
        if global.keyWeaponSwitchLeft[playerID] &amp;&amp; global.keyWeaponSwitchRight[playerID]
        {
            if rResetTimer == 0
                playSFX(sfxHoldPrompt);
            if rResetTimer != -1    //stop advancing if you're still holding after a reset
                rResetTimer += 1/60;
            if rResetTimer &gt;= 1
            { //reset
                playSFX(sfxMenuSelect);
                for (var i = 0; i &lt;= global.totalWeapons; i++)
                    global.weaponHotbar[i] = i;
                rResetTimer = -1;
            }
        }
        else
        {
            if rResetTimer &gt; 0
                stopSFX(sfxHoldPrompt);
            rResetTimer = 0;
        }
        
        //selection
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            &amp;&amp; rAnimTime &lt;= 0
        {
            var err = false;
            
            if option == 6
            {   //option 6: done rearranging!
                playSFX(sfxMenuSelect);
                phase = 2;
            }
            else if option &gt;= 10
            {   //swap weapons
                if global.weaponHotbar[option - 10] == 0 &amp;&amp; --rBusterResistance &gt; 0
                {   //buster gives you an error the first few attempts
                    playSFX(sfxError);
                    err = true;
                }
                else if rHeldWeapon == undefined
                {   //pick up weapon, if you're not holding one
                    if global.weaponLocked[global.weaponHotbar[option - 10]] != 2
                    {
                        rHeldWeapon = option - 10;
                        rCursorX = buttonPos[option, 0] - 28;
                        rCursorY = buttonPos[option, 1];
                    }
                    else
                    {   //trying to pick up nonweapon does nothing
                        //playSFX(sfxError);
                        err = true;
                    }
                }
                else
                {   //exchange option with held weapon
                    var k = global.weaponHotbar[rHeldWeapon];
                    global.weaponHotbar[rHeldWeapon] = global.weaponHotbar[option - 10];
                    global.weaponHotbar[option - 10] = k;
                    
                    if !(global.weaponLocked[global.weaponHotbar[rHeldWeapon]] == 2
                        || option - 10 == rHeldWeapon)
                    {   //swap anim
                        rCursorAnim = 2;
                        rAnimTime = 10;
                        rAnimatingOption = option;
                        playSFX(sfxClamp);
                    }
                    else    //i.e. if option is hidden, or is same as held option
                    {   //put down anim (weps are still swapped internally)
                        rCursorAnim = 1;
                        rAnimTime = 5;
                        rAnimatingOption = option;
                        rHeldWeapon = undefined;
                        playSFX(sfxClamp);
                    }
                }
                
                //get colors of held option
                if !err
                {
                    if rHeldWeapon != undefined
                        global.weapon[playerID] = global.weaponHotbar[rHeldWeapon];
                    else
                        global.weapon[playerID] = global.weaponHotbar[option - 10];
                    with (objMegaman)
                        playerPalette();
                    rCursorPriCol = global.primaryCol[playerID];
                    rCursorSecCol = global.secondaryCol[playerID];
                    //reset colors after
                    global.weapon[playerID] = global.weaponHotbar[option - 10];
                    with (objMegaman)
                        playerPalette();
                }
                
                //sound when buster gives up
                if rBusterResistance == 0
                {
                    playSFX(sfxMinorExplosion);
                    stopSFX(sfxClamp);
                    rBusterResistance--;
                }
            }
            else
            {
                playSFX(sfxError);  //safeguard: other options do nothing
            }
        }
        
        //cursor function
        if rHeldWeapon != undefined
        {
            rCursorX += ((buttonPos[option, 0] - 28) - rCursorX) / 3;
            rCursorY += ((buttonPos[option, 1] - 8) - rCursorY) / 3;
        }
        
        //animations
        //most of the relevant code is in the draw event
        if rAnimTime &lt;= 0
            rCursorAnim = 0;
        else
            rAnimTime--;
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///find nearest button

//takes buttonPos, varDir, dir, cursorPos, option. outputs to option

//moving away from an option deconfirms it
confirm = false;

nearestOption = -1;
var closePoints;
var nearestClosePoints = 999999;

for(var p = 0; p &lt; array_height_2d(buttonPos); p++)
{
    //non-options aren't options
    if buttonPos[p, 0] == undefined
        continue;
    
    //don't allow selection of non-weapons while in certain modes
    //(picking weapon for w-tank and weapon rearranging mode)
    if phase &gt;= 6 &amp;&amp; ((p &lt; 10) 
        &amp;&amp; !(phase == 7 &amp;&amp; rHeldWeapon == undefined &amp;&amp; p == 6))
        continue;
    
    //don't allow selecting weapons that are locked
    //(unless in rearrange mode)
    if phase != 7 
        &amp;&amp; p &gt;= 10 &amp;&amp; global.weaponLocked[global.weaponHotbar[p - 10]] &gt;= 1
        continue;

    //draw a plane cutting away all options that aren't in the direction of movement
    if ((buttonPos[p, dir] - cursorPos[dir]) * varDir[dir])
    //offset the plane by the difference in position perpindicular to movement
    /*
    this is to keep it from selecting options that are just slightly further
    to the right than the current one, but very far away vertically,
    that may get selected if you push the edges of the menu
    */
        - abs(cursorPos[!dir] - buttonPos[p, !dir]) &gt; 0
    {
        //buttons get points. more points = bad
        closePoints = abs(cursorPos[dir] - buttonPos[p, dir]);
        //the perpindicular direction is accounted for, but deprioritized
        closePoints += abs(cursorPos[!dir] - buttonPos[p, !dir]) * 3;
        
        //if current button is closer than previous record-setter, replace it
        if (closePoints &lt; nearestClosePoints)
        {
            nearestOption = p;
            nearestClosePoints = closePoints;
        }
    }
}

//-1 means it did not find an option in that direction
if !(nearestOption == -1 || nearestOption == option)
{
    option = nearestOption;
    playSFX(sfxWeaponSwitch);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///general using an option

if (option &gt;= 10)
{   //select weapon
    if (instance_exists(objMegaman.vehicle) &amp;&amp; global.weaponHotbar[option - 10] == 0)
    {
        if (!objMegaman.vehicle.weaponsAllowed)
        {
            playSFX(sfxError);
            exit;
        }
    }
    
    if global.weaponLocked[global.weaponHotbar[option - 10]]
    {
        playSFX(sfxError);
        exit;
    }
    
    global.nextRoom = -1;
    phase = 3;
    
    global.weapon[playerID] = global.weaponHotbar[option - 10];
    playSFX(sfxMenuSelect);
}
else
{
    switch(option)
    {
        case 0: //e-tank
            if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
            {
                option = -1; // Nothing selected
                phase = 5;
                wtank = 0;
                mtank = 0;
                global.eTanks -= 1;
                eTankTimer = 0;
                loopSFX(sfxEnergyRestore);
            }
            else
                playSFX(sfxError);
            break;
        
        case 1://w-tank
            // Check if weapon energy actually needs filling
            var proceed = false;
            for (i = 0; i &lt; 11; i += 1)
            {
                if (ceil(global.ammo[playerID, global.weaponHotbar[i]]) &lt; 28)
                {
                    proceed = true;
                    break;
                }
            }
            
            if (global.wTanks &amp;&amp; proceed)
            {
                option = indexOf(global.weaponHotbar, oldWeapon) + 10; //Jump to weapon list
                //note: doesn't use tank immediately!
                phase = 6;
                mtank = 0;
                wtank = 1;
                playSFX(sfxMenuSelect);
            }
            else
                playSFX(sfxError);
            break;
        
        case 2: //m-tank
            // Check if health or weapon energy actually needs filling
            if (global.mTanks &gt; 0)
            {
                var proceed = false;
                if (ceil(global.playerHealth[playerID]) &lt; 28)
                    proceed = true;
                else
                {
                    for (i = 0; i &lt; 11; i += 1)
                    {
                        if (ceil(global.ammo[playerID, global.weaponHotbar[i]]) &lt; 28)
                        {
                            proceed = true;
                            break;
                        }
                    }
                }
                
                if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                {
                    option = -1; // Nothing selected
                    phase = 5;
                    mtank = 1;
                    wtank = 0;
                    global.mTanks -= 1;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                    playSFX(sfxError);
            }
            else
                playSFX(sfxError);
            break;
        
        case 3: //options
            with instance_create(x, y, objOptionsMenu)
                link = other;
            playSFX(sfxMenuSelect);
            break;
        
        case 4: //retry
        case 5: //exit
            //exit button acts as map instead in some rooms
            if !useExit &amp;&amp; option == 5
            {
                with instance_create(x, y, objMapMenu)
                    link = other;
                playSFX(sfxMenuSelect);
                break;
            }
            //else, confirmation prompt
            if (!confirm)
            {
                confirm = true;
                playSFX(sfxMenuSelect);
                exit;
            }
            else if !global.nextRoom
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    if option == 4
                        global.nextRoom = room;
                    else
                        returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            break;
        
        case 6: //rearrange weapons
            playSFX(sfxMenuSelect);
            phase = 7;
            break;
        
        case 7: //info
        {
            with(instance_create(x, y, objDescriptionMenu))
            {
                link = other;
                option = other.oldWeapon;
            }
            playSFX(sfxElementGrab);
        }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving between options
var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);
var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);

cursorPos[0] = buttonPos[option, 0];
cursorPos[1] = buttonPos[option, 1];
varDir[0] = xDir;
varDir[1] = yDir;

if (yDir != 0)
{
    //vertical movement while NOT on the weapon list
    dir = 1;
    event_user(5);
    
    //if scrolled off the menu, try again from the other side
    if nearestOption = -1
    {
        cursorPos[1] -= view_hview * yDir * 3;
        event_user(5);
    }
}

if (xDir != 0)    //same as above
{
    dir = 0;
    event_user(5);
    
    if nearestOption = -1
    {
        cursorPos[0] -= view_wview * xDir * 3;
        event_user(5);
    }
}

//handle player's pallete changing to match weapon
if (option &gt;= 10) &amp;&amp; (global.weaponLocked[global.weaponHotbar[option - 10]] != 2)
    global.weapon[playerID] = global.weaponHotbar[option - 10];
else
    global.weapon[playerID] = oldWeapon;

with (objMegaman)
    playerPalette();
    
//weapon dynamic refill
var we;
for(var q = 0; q &lt;= 11; q++)
{
    if rHeldWeapon == q
        we = 0;
    else if global.weaponHotbar[q] == 0
        we = global.playerHealth[playerID];
    else if !global.weaponLocked[global.weaponHotbar[q]]
        we = global.ammo[playerID, global.weaponHotbar[q]];
    else
        we = 0;
    
    wepBarFills[q] = decreaseMagnitude(wepBarFills[q] - we, 0.5 + (abs(wepBarFills[q] - we) / 3)) + we;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// center in screen on nonstandard resolutions
x = view_xview + ((view_wview[0] - 256) / 2) + scrollX;
y = view_yview + ((view_hview[0] - 224) / 2) + scrollY;

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    draw_clear(c_black);
    
    var col;
    col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;
    
    //cool backing
    bgTimer += 0.25;
    var sx = (scrollX / 2) + abs((bgTimer mod 1440) - 720);
    var sy = (scrollY / 2) + abs(((bgTimer + 360) mod 1440) - 720);
    for(var i = (sy mod 120) - 120; i &lt;= view_hview; i += 120)
    {
        for(var j = (sx mod 120) - 120; j &lt;= view_wview; j += 120)
        {
            draw_background(bgArcadeCarpet, view_xview + j, view_yview + i);
        }
    }
    //fadebox for going to options menu
    draw_set_alpha(floor(min(linkFade, 1) * 3) / 3);
    draw_rectangle_color(view_xview, view_yview, view_xview + view_wview, view_yview + view_hview,
        false, c_black, c_black, c_black, c_black);
    draw_set_alpha(1);
    
    // these actually go 'under' the pause menu, so they go before drawSelf.
    
    // Options
    draw_sprite_ext(sprGotoOptions, (option == 3), x + optionsPositionX, y + optionsPositionY, 1, 1, 0, c_white, 1);
    
    // Checkpoint
    draw_sprite_ext(sprGotoCheckpoint, (option == 4) * (confirm + 1), x + checkPositionX, y + checkPositionY, 1, 1, 0, c_white, 1);
    
    // Exit
    draw_sprite_ext(sprExit, ((option == 5) * (confirm + 1)) + (!useExit * 4), x + exitPositionX, y + exitPositionY, 1, 1, 0, c_white, 1);

    // Sort &amp; Info
    var isgreen = (phase == 7);
    draw_sprite_ext(sprWeaponSort, (option == 6) + ((option == 7) * 2) + (isgreen * 3), x + rearrangePositionX, y + rearrangePositionY, 1, 1, 0, c_white, 1);
    
    // NOW draw itself
    var isred = ((phase == 6) || (phase == 5 &amp;&amp; wtank)) * 2;
    draw_sprite(sprite_index, isred + isgreen, x, y);
    
    //weapons
    var xff, yff, w, ammo, wname, cl;
    for(var p = 10; p &lt;= 21; p++)
    {
        xff = x + buttonPos[p, 0] + -28;
        yff = y + buttonPos[p, 1];
        w = global.weaponHotbar[p - 10];
        cl = (option == p);
        ammo = wepBarFills[p - 10];
        
        //slot appears filled if weapon is not hidden or held
        if global.weaponLocked[w] != 2 &amp;&amp; rHeldWeapon != p - 10
        {
            //icon
            if cl
            {
                draw_sprite_ext(global.weaponIcon[w], 0, xff, yff, 1, 1, 0, col[!cl, 2], 1);
                draw_sprite_ext(global.weaponIcon[w], 1, xff, yff, 1, 1, 0, col[0, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 2, xff, yff, 1, 1, 0, col[1, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 3, xff, yff, 1, 1, 0, col[1, 2], cl);
            }
            else
            draw_sprite_ext(global.weaponIcon[w], 0, xff, yff, 1, 1, 0, c_white, 1);
        
            if global.weaponLocked[w] == 0
            {   //name, if unlocked
                //determine breakpoint in name to indent it
                wname = global.weaponName[w];
                var brk = 0;
                if string_length(wname) &gt; 8
                {
                    brk = string_pos(" ", wname);
                    if (brk)
                        wname = string_insert("#", wname, brk);
                }
                //black rectangles to prevent text overlapping tiles
                draw_set_color(c_black);
                if brk != 0
                {
                    draw_rectangle(xff + 17, yff, xff + 8 + (brk * 8), yff + 8, false);
                    draw_rectangle(xff + 25, yff + 8, xff + 16 + ((string_length(wname) - brk) * 8), yff + 16, false);
                }
                else
                    draw_rectangle(xff + 17, yff + 0, xff + 16 + (string_length(wname) * 8), yff + 8, false);
                //draw the actual name
                draw_set_color(col[!cl, cl * 2]);
                draw_text(xff + 17, yff, wname);
                draw_set_color(c_white);
            }
            else    //i.e. if global.weaponLocked[w] == 1
            {   //locked icon if locked
                draw_sprite_ext(sprPauseMenuWeaponDisabled, 0, xff + 17, yff, 1, 1, 0, c_white, 1);
            }
                
            //ammo bar
            draw_sprite_ext(sprPauseMenuBarPrimary, ammo, xff + 8, yff + 16, 1, 1, 0, col[0, cl * (1 + (w == 0))], 1);
            draw_sprite_ext(sprPauseMenuBarSecondary, ammo, xff + 8, yff + 16, 1, 1, 0, col[1, cl * (1 + (w == 0))], 1);
            
            // Draw infinite energy mark over relevant bars
            if (global.infiniteEnergy[w])
            {
                draw_sprite_ext(sprInfinityMark, 0, xff + 24 + 12, yff + 16, 1, 1, 0, c_white, 1);
                draw_sprite_ext(sprInfinityMark, 1, xff + 24 + 12, yff + 16, 1, 1, 0, col[0, cl], 1);
                draw_sprite_ext(sprInfinityMark, 2, xff + 24 + 12, yff + 16, 1, 1, 0, col[1, cl], 1);
            }
        }
        else if phase == 7
        {   //empty weapon slot
            //"icon"
            draw_sprite_ext(sprWeaponIconsBlank, 0, xff, yff, 1, 1, 0, col[cl, 0], 1);
            //grey energy bar
            draw_sprite_ext(sprPauseMenuBarPrimary, ammo, xff + 8, yff + 16, 1, 1, 0, col[0, 0], 1);
            draw_sprite_ext(sprPauseMenuBarSecondary, ammo, xff + 8, yff + 16, 1, 1, 0, col[1, 0], 1);
        }
    }
    
    if !isgreen &amp;&amp; !isred
    {
        // mega man
        with (objMegaman)
        {
            if (playerID == other.playerID)
            {
                drawPlayer(playerID, costumeID, 0, 0, other.x + 41, other.y + 16, 1, 1);
            }
        }
        
        // health
        draw_sprite_ext(sprPauseMenuBarPrimary, global.playerHealth[playerID], x + 55, y + 8, 1, 1, 0, col[0, 2], 1);
        draw_sprite_ext(sprPauseMenuBarSecondary, global.playerHealth[playerID], x + 55, y + 8, 1, 1, 0, col[1, 2], 1);
        
        // E-Tank
        draw_sprite_ext(sprETank, 2, x + etankPositionX, y + etankPositionY + -1, 1, 1, 0, col[0, option == 0], 1);
        draw_sprite_ext(sprETank, 4, x + etankPositionX, y + etankPositionY + -1, 1, 1, 0, col[1, option == 0], 1);
        
        draw_text(x + etankPositionX, y + etankPositionY + 16, zeroPad(global.eTanks, 2));
        
        // W-Tank
        draw_sprite_ext(sprWTank, 2, x + wtankPositionX, y + wtankPositionY + -1, 1, 1, 0, col[0, option == 1], 1);
        draw_sprite_ext(sprWTank, 4, x + wtankPositionX, y + wtankPositionY + -1, 1, 1, 0, col[1, option == 1], 1);
        
        draw_text(x + wtankPositionX, y + wtankPositionY + 16, zeroPad(global.wTanks, 2));
        
        // M-Tank
        draw_sprite_ext(sprMTank, 2, x + mtankPositionX, y + mtankPositionY + -1, 1, 1, 0, col[0, option == 2], 1);
        draw_sprite_ext(sprMTank, 4, x + mtankPositionX, y + mtankPositionY + -1, 1, 1, 0, col[1, option == 2], 1);
        
        draw_text(x + mtankPositionX, y + mtankPositionY + 16, zeroPad(global.mTanks, 2));
        
        // Bolts
        draw_sprite_ext(sprBoltBig, 0, x + 200, y + 5, 1, 1, 0, c_white, 1);
        draw_sprite_ext(sprBoltBig, 1, x + 200, y + 5, 1, 1, 0, col[0, 1], 1);
        draw_sprite_ext(sprBoltBig, 2, x + 200, y + 5, 1, 1, 0, col[1, 1], 1);
        
        draw_text(x + 192, y + 24, zeroPad(global.bolts, 4));
        
        // Energy Elements
        draw_sprite_ext(sprEnergyElement, 0, x + 136, y + 7, 1, 1, 0, c_white, 1);
        
        draw_text(x + 133, y + 24, zeroPad(global.energyElements, 3));
        
        // Side Collectible
        draw_sprite_ext(sprKey, 0, x + 168, y + 8, 1, 1, 0, c_white, 1);
        
        draw_text(x + 165, y + 24, zeroPad(0, 3));
    }
    else
    {
        //draw explanatory text
        draw_set_halign(fa_center); 
        if(isred)
            draw_text(x + 128, y + 8, "W-TANK MODE#Choose a weapon to use#a W-Tank on.#Press B to cancel.")
        else
        {
            draw_text(x + 128, y + 8, "REARRANGE MODE#Swap weapons with A.#Hold L and R to reset.")
            if rResetTimer &gt; 0
            {
                if bgTimer mod 3 &gt;= 1
                    draw_set_color(global.nesPalette[36]);
                draw_rectangle(x + 64, y + 33, x + 64 + floor((128 * rResetTimer) + 0.05),
                    y + 39, false);
                draw_set_color(c_white);
            }
        }
        draw_set_halign(fa_left);
    }
    
    //rearrange mode stuff
    //cursor
    if phase == 7
    {
        //swap is 2
        //put down is 1
        //pickup is a property of the cursor smoothing
        if rAnimatingOption != undefined
            var ic = global.weaponIcon[global.weaponHotbar[rAnimatingOption - 10]];
        if rHeldWeapon != undefined
            var ic2 = global.weaponIcon[global.weaponHotbar[rHeldWeapon]];
        
        var ra = rAnimTime / 10;
        
        if rHeldWeapon != undefined &amp;&amp; rCursorAnim == 0
        {   //standard cursor movement
            var ico = global.weaponIcon[global.weaponHotbar[rHeldWeapon]];
            draw_sprite_ext(ico, 0, x + rCursorX, y + rCursorY, 1, 1, 0, col[0, 2], 1);
            draw_sprite_ext(ico, 1, x + rCursorX, y + rCursorY, 1, 1, 0, rCursorPriCol, 1);
            draw_sprite_ext(ico, 2, x + rCursorX, y + rCursorY, 1, 1, 0, rCursorSecCol, 1);
            draw_sprite_ext(ico, 3, x + rCursorX, y + rCursorY, 1, 1, 0, col[1, 2], 1);
        }
        else if rHeldWeapon != undefined &amp;&amp; rCursorAnim == 2
        {   //swap anim
            var asrcX = x + buttonPos[rAnimatingOption, 0] + -28;
            var asrcY = y + buttonPos[rAnimatingOption, 1];
            var swapAdjX = ((x + rCursorX) - asrcX) * sin(((1 - ra) * pi * 0.5));
            swapAdjX = swapAdjX + (sin(ra * pi) * 10);
            var swapAdjY = ((y + rCursorY) - asrcY) * ((cos(ra * pi) + 1) / 2);
            
            draw_sprite_ext(sprWeaponIconsBlank, 0, asrcX, asrcY, 1, 1, 0, col[0, 0], 1);
            
            //icon 1 if behind
            if rAnimTime &lt; 5
            {
                draw_sprite_ext(ic, 0, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[option != rAnimatingOption, 2], 1);
                draw_sprite_ext(ic, 1, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[0, option == rAnimatingOption], 1);
                draw_sprite_ext(ic, 2, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[1, option == rAnimatingOption], 1);
                draw_sprite_ext(ic, 3, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[1, 2], option == rAnimatingOption);
            }
            
            //icon 2
            draw_sprite_ext(ic2, 0, asrcX + swapAdjX, asrcY + swapAdjY, 1, 1, 0, col[0, 2], 1);
            draw_sprite_ext(ic2, 1, asrcX + swapAdjX, asrcY + swapAdjY, 1, 1, 0, rCursorPriCol, 1);
            draw_sprite_ext(ic2, 2, asrcX + swapAdjX, asrcY + swapAdjY, 1, 1, 0, rCursorSecCol, 1);
            draw_sprite_ext(ic2, 3, asrcX + swapAdjX, asrcY + swapAdjY, 1, 1, 0, col[1, 2], 1);
            
            //icon 1 if in front
            if rAnimTime &gt;= 5
            {
                draw_sprite_ext(ic, 0, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[option != rAnimatingOption, 2], 1);
                draw_sprite_ext(ic, 1, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[0, option == rAnimatingOption], 1);
                draw_sprite_ext(ic, 2, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[1, option == rAnimatingOption], 1);
                draw_sprite_ext(ic, 3, x + rCursorX + -swapAdjX, y + rCursorY + -swapAdjY, 1, 1, 0, col[1, 2], option == rAnimatingOption);
            }
        }
        else if rCursorAnim == 1
        {   //put down anim
            var asrcX = x + buttonPos[rAnimatingOption, 0] + -28;
            var asrcY = y + buttonPos[rAnimatingOption, 1];
            var adjX = ((x + rCursorX) - asrcX) * sin(ra * pi * 0.25);
            var adjY = ((y + rCursorY) - asrcY) * sin(ra * pi * 0.25);
            
            draw_sprite_ext(sprWeaponIconsBlank, 0, asrcX, asrcY, 1, 1, 0, col[option == rAnimatingOption, 0], 1);
            
            draw_sprite_ext(ic, 0, asrcX + adjX, asrcY + adjY, 1, 1, 0, col[option != rAnimatingOption, 2], 1);
            draw_sprite_ext(ic, 1, asrcX + adjX, asrcY + adjY, 1, 1, 0, col[0, option == rAnimatingOption], 1);
            draw_sprite_ext(ic, 2, asrcX + adjX, asrcY + adjY, 1, 1, 0, col[1, option == rAnimatingOption], 1);
            draw_sprite_ext(ic, 3, asrcX + adjX, asrcY + adjY, 1, 1, 0, col[1, 2], option == rAnimatingOption);
        }
    }
    
    // colored text overlays
    if (global.showColoredTextOverlays)
    {
        draw_sprite_ext(sprDot, 0, x + 16, y, view_wview[0] - 32, view_hview[0], 0,
            make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
            global.coloredTextOverlaysOpacity / 255);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
