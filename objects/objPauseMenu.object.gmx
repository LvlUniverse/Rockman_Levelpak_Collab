<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPauseMenuNew</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = 0;

phase = 0; // 0: increasing the black rectangle's alpha

oldWeapon = global.weapon[0];
option = 10 + min(indexOf(global.weaponHotbar, oldWeapon), 11);
oldOption = option;

wtank = 0;
mtank = 0;

confirm = false;

playerID = 0;
costumeID = 0;

// Stop charging
with (objMegaman)
{
    playerPalette();
}

// set these here. makes everyone's lives easier.

etankPositionX = 57;   buttonPos[0, 0] = etankPositionX; 
etankPositionY = 51;    buttonPos[0, 1] = etankPositionY - 100; 
wtankPositionX = 85;   buttonPos[1, 0] = wtankPositionX;
wtankPositionY = 51;    buttonPos[1, 1] = wtankPositionY - 100;
mtankPositionX = 30;   buttonPos[2, 0] = mtankPositionX;
mtankPositionY = 51;    buttonPos[2, 1] = mtankPositionY - 100;  

optionsPositionX = 136; buttonPos[3, 0] = optionsPositionX + 11;
optionsPositionY = 208; buttonPos[3, 1] = optionsPositionY + 100;
checkPositionX = 158;   buttonPos[4, 0] = checkPositionX + 23;
checkPositionY = 208;   buttonPos[4, 1] = checkPositionY + 100;
exitPositionX = 204;    buttonPos[5, 0] = exitPositionX + 18;
exitPositionY = 208;    buttonPos[5, 1] = exitPositionY + 100;

rearrangePositionX = 18;    buttonPos[6, 0] = rearrangePositionX + 34;
rearrangePositionY = 205;    buttonPos[6, 1] = rearrangePositionY + 100;
infoPositionX = 88;    buttonPos[7, 0] = infoPositionX + 11;
infoPositionY = 205;    buttonPos[7, 1] = infoPositionY + 100;

//these buttons aren't anything. but, they could be!
buttonPos[8, 0] = undefined;
buttonPos[9, 0] = undefined;

//weapons at (38, 91), spaced 93x, 18y
for(var p = 0; p &lt;= 11; p++)
{
    buttonPos[p + 10, 0] = 38 + 28 + (floor(p / 6) * 92);
    buttonPos[p + 10, 1] = 99 + ((p mod 6) * 18);
}

rHeldWeapon = undefined;
rCursorAnim = 0;
rAnimTime = 0;
rearrangeCursorX = 0;
rearrangeCursorY = 0;
for(var q = 0; q &lt;= 11; q++)
{
    print(global.weaponHotbar[q]);
    if global.weaponHotbar[q] == 0
        wepBarFills[q] = global.playerHealth[playerID];
    else if !global.weaponLocked[global.weaponHotbar[q]]
        wepBarFills[q] = global.ammo[playerID, global.weaponHotbar[q]];
    else
        wepBarFills[q] = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while a submenu is open
if (instance_exists(objOptionsMenu) || instance_exists(objDescriptionMenu))
{
    exit;
}

// do pause menu
switch (phase)
{
    // Fading out
    case 0:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1)
            {
                global.nextRoom = 0;
                other.visible = 1;
                other.phase = 1;
                showhealth = 0;
            }
        }
        break;
    
    // Fading in
    case 1:
        with (objGlobalControl)
        {
            if (fadeAlpha == 0)
            {
                other.phase = 2;
            }
        }
        event_user(0); // Moving the selection
        
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        //if b is pressed...
        if global.keyShootPressed[playerID]
        {
            if(confirm) //cancel confirm if confirming
                confirm = false;
            else
            {   //elsewise, leave weapon menu without switching weapons
                option = oldOption;
                global.weapon[playerID] = oldOption - 10;
                global.nextRoom = -1;
                phase = 3;
                playSFX(sfxSkullAmulet);
                exit;
            }
        }
        
        // Select the weapon/tank
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            event_user(1);
        
        break;
    
    // Fading out
    case 3:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1 &amp;&amp; global.nextRoom != 0)
            {
                showhealth = 1;
                with (other)
                {
                    if (global.weapon[playerID] != oldWeapon)
                    {
                        with (prtPlayerProjectile)
                        {
                            instance_destroy();
                        }
                    }
                    
                    global.nextRoom = 0;
                    visible = 0;
                }
            }
            else if (fadeAlpha == 0 &amp;&amp; global.nextRoom == 0)
            {
                with (other)
                {
                    audio_resume_all();
                    instance_destroy();
                    global.frozen = 0;
                }
            }
        }
        
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, global.weaponHotbar[option - 10]] &lt; 28)
                {
                    global.ammo[playerID, global.weaponHotbar[option - 10]] = min(28,
                        global.ammo[playerID, global.weaponHotbar[option - 10]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; array_length_1d(global.weaponHotbar); i++;)
                {
                    if (global.ammo[playerID, global.weaponHotbar[i]] &lt; 28)
                    {
                        global.ammo[playerID, global.weaponHotbar[i]] = min(28,
                            global.ammo[playerID, global.weaponHotbar[i]] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = oldOption;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                else
                {
                    if global.wTanks &gt; 0
                        phase = 6;
                    else
                        option = 1;
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        for(var q = 0; q &lt;= 11; q++)
        {
            wepBarFills[q] = global.ammo[playerID, global.weaponHotbar[q]];
        }
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
        //quit from selection if player presses shoot
        if global.keyShootPressed[playerID]
        {
            option = 1;
            phase = 2;
        }
        else if (option &gt;= 10)
        {
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, global.weaponHotbar[option - 10]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                    global.wTanks -= 1;
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        
        break;
    
    case 7: //Rearrange weapons
        event_user(0);  //allow selection of weapons
        
        //if b is pressed, return weapons to their original places
        if global.keyShootPressed[playerID]
        {
            global.weaponHotbar = preRearrange;
            phase = 2;
            playSFX(sfxSkullAmulet);
            exit;
        }
        
        //selection
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            &amp;&amp; rAnimTime &lt;= 0
        {
            if option == 6
            {   //option 6: done rearranging!
                playSFX(sfxMenuSelect);
                phase = 2;
                preRearrange = undefined;
            }
            else if option &gt;= 10
            {   //swap weapons
                if rHeldWeapon == undefined
                {   //pick up weapon
                    rHeldWeapon = option - 10;
                    rCursorAnim = -1;
                    rAnimTime = 10;
                }
                else
                {   //exchange option with held weapon
                    var k = global.weaponHotbar[rHeldWeapon];
                    global.weaponHotbar[rHeldWeapon] = global.weaponHotbar[option - 10];
                    global.weaponHotbar[option - 10] = k;
                    
                    if !(global.weaponLocked[global.weaponHotbar[option - 10]] == 2
                        || option - 10 == rHeldWeapon)
                    {   //swap anim
                        rCursorAnim = 2;
                        rAnimTime = 10;
                        playSFX(sfxClamp);
                    }
                    else
                    {   //put down anim (weps are still swapped internally)
                        rCursorAnim = 1;
                        rAnimTime = 10;
                        rHeldWeapon = undefined;
                        playSFX(sfxClamp);
                    }
                }
            }
            else
            {
                playSFX(sfxError);  //safeguard: other options do nothing
            }
        }
        
        //test anim
        rAnimTime--;
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///find nearest button

//takes buttonPos, varDir, dir, cursorPos, option. outputs to option

//moving away from an option deconfirms it
confirm = false;

nearestOption = -1;
var closePoints;
var nearestClosePoints = 999999;

for(var p = 0; p &lt; array_height_2d(buttonPos); p++)
{
    //non-options aren't options
    if buttonPos[p, 0] == undefined
        continue;
    
    //don't allow selection of non-weapons while in certain modes
    //(picking weapon for w-tank and weapon rearranging mode)
    if phase &gt;= 6 &amp;&amp; ((p &lt; 10) 
        &amp;&amp; !(phase == 7 &amp;&amp; rHeldWeapon == undefined &amp;&amp; p == 6))
        continue;
    
    //don't allow selecting weapons that are locked
    //(unless in rearrange mode)
    if phase != 7 
        &amp;&amp; p &gt;= 10 &amp;&amp; global.weaponLocked[global.weaponHotbar[p - 10]] &gt;= 1
        continue;

    //draw a plane cutting away all options that aren't in the direction of movement
    if ((buttonPos[p, dir] - cursorPos[dir]) * varDir[dir])
    //offset the plane by the difference in position perpindicular to movement
    /*
    this is to keep it from selecting options that are just slightly further
    to the right than the current one, but very far away vertically,
    that may get selected if you push the edges of the menu
    */
        - abs(cursorPos[!dir] - buttonPos[p, !dir]) &gt; 0
    {
        //buttons get points. more points = bad
        closePoints = abs(cursorPos[dir] - buttonPos[p, dir]);
        //the perpindicular direction is accounted for, but deprioritized
        closePoints += abs(cursorPos[!dir] - buttonPos[p, !dir]) * 3;
        
        //if current button is closer than previous record-setter, replace it
        if (closePoints &lt; nearestClosePoints)
        {
            nearestOption = p;
            nearestClosePoints = closePoints;
        }
    }
}

//-1 means it did not find an option in that direction
if !(nearestOption == -1 || nearestOption == option)
{
    option = nearestOption;
    playSFX(sfxWeaponSwitch);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///general using an option

if (option &gt;= 10)
{   //select weapon
    if (instance_exists(objMegaman.vehicle) &amp;&amp; option != 10)
    {
        if (!objMegaman.vehicle.weaponsAllowed)
        {
            playSFX(sfxError);
            exit;
        }
    }
    
    if global.weaponLocked[global.weaponHotbar[option - 10]]
    {
        playSFX(sfxError);
        exit;
    }
    
    global.nextRoom = -1;
    phase = 3;
    
    global.weapon[playerID] = global.weaponHotbar[option - 10];
    playSFX(sfxMenuSelect);
}
else
{
    switch(option)
    {
        case 0: //e-tank
            if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
            {
                option = -1; // Nothing selected
                phase = 5;
                wtank = 0;
                mtank = 0;
                global.eTanks -= 1;
                eTankTimer = 0;
                loopSFX(sfxEnergyRestore);
            }
            else
                playSFX(sfxError);
            break;
        
        case 1://w-tank
            // Check if weapon energy actually needs filling
            var proceed = false;
            for (i = 0; i &lt; 11; i += 1)
            {
                if (ceil(global.ammo[playerID, global.weaponHotbar[i]]) &lt; 28)
                {
                    proceed = true;
                    break;
                }
            }
            
            if (global.wTanks &amp;&amp; proceed)
            {
                option = oldOption; //Jump to weapon list
                //note: doesn't use tank immediately!
                phase = 6;
                mtank = 0;
                wtank = 1;
                playSFX(sfxMenuSelect);
            }
            else
                playSFX(sfxError);
            break;
        
        case 2: //m-tank
            // Check if health or weapon energy actually needs filling
            if (global.mTanks &gt; 0)
            {
                var proceed = false;
                if (ceil(global.playerHealth[playerID]) &lt; 28)
                    proceed = true;
                else
                {
                    for (i = 0; i &lt; 11; i += 1)
                    {
                        if (ceil(global.ammo[playerID, global.weaponHotbar[i]]) &lt; 28)
                        {
                            proceed = true;
                            break;
                        }
                    }
                }
                
                if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                {
                    option = -1; // Nothing selected
                    phase = 5;
                    mtank = 1;
                    wtank = 0;
                    global.mTanks -= 1;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                    playSFX(sfxError);
            }
            else
                playSFX(sfxError);
            break;
        
        case 3: //options
            instance_create(x, y, objOptionsMenu);
            playSFX(sfxMenuSelect);
            break;
        
        case 4: //retry
        case 5: //exit
            if (!confirm)
            {
                confirm = true;
                playSFX(sfxMenuSelect);
                exit;
            }
            else if !global.nextRoom
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    if option == 4
                        global.nextRoom = room;
                    else
                        returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            break;
        
        case 6: //rearrange weapons
            playSFX(sfxMenuSelect);
            phase = 7;
            preRearrange = global.weaponHotbar;
            break;
        
        case 7: //info
        {
            with(instance_create(x, y, objDescriptionMenu))
            {
                link = other;
                option = other.oldOption - 10;
            }
            playSFX(sfxElementGrab);
        }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving between options
var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);
var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);

cursorPos[0] = buttonPos[option, 0];
cursorPos[1] = buttonPos[option, 1];
varDir[0] = xDir;
varDir[1] = yDir;

if (yDir != 0)
{
    //vertical movement while NOT on the weapon list
    dir = 1;
    event_user(5);
    
    //if scrolled off the menu, try again from the other side
    if nearestOption = -1
    {
        cursorPos[1] -= view_hview * yDir * 3;
        event_user(5);
    }
}

if (xDir != 0)    //same as above
{
    dir = 0;
    event_user(5);
    
    if nearestOption = -1
    {
        cursorPos[0] -= view_wview * xDir * 3;
        event_user(5);
    }
}

////TODO: this should only work while in rearrange mode
////also, TODO rearrange mode
/*
// L + R resets weapon order

// it only checks for one pressed because if it checked both you'd have to press both
// buttons on the same frame, but if you could just hold the two buttons you would get
// a very loud screeching noise every time you reset + it'd be easier to accidentally
// sort
if ((global.keyWeaponSwitchLeft[playerID] &amp;&amp; global.keyWeaponSwitchRightPressed[playerID])
    || (global.keyWeaponSwitchLeftPressed[playerID] &amp;&amp; global.keyWeaponSwitchRight[playerID]))
{
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if global.weaponHotbar[i] != i
        {
            global.weaponHotbar[i] = i;
            playSFX(sfxMenuSelect);
        }
    }
    
    weaponVisibleN = 0;
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
        {
            weaponVisible[weaponVisibleN++] = i;
        }
    }
    visibleWeapons = min(10, weaponVisibleN); // up to 10 visible
    oldOption = 0;
}
*/

//handle player's pallete changing to match weapon
if  rHeldWeapon == undefined
{
    if (option &gt;= 10) &amp;&amp; (global.weaponLocked[option - 10] != 2)
        global.weapon[playerID] = global.weaponHotbar[option - 10];
    else
        global.weapon[playerID] = oldOption - 10;
}
else    //i.e. if rHeldWeapon != undefined
{
    global.weapon[playerID] = global.weaponHotbar[rHeldWeapon];
}

with (objMegaman)
    playerPalette();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// center in screen on nonstandard resolutions
x = view_xview + (view_wview[0] - 256) / 2;
y = view_yview + (view_hview[0] - 224) / 2;

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    draw_clear(c_black);
    
    var col;
    col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;
    
    // these actually go 'under' the pause menu, so they go before drawSelf.
    
    // Options
    draw_sprite_ext(sprGotoOptions, (option == 3), x + optionsPositionX, y + optionsPositionY, 1, 1, 0, c_white, 1);
    
    // Checkpoint
    draw_sprite_ext(sprGotoCheckpoint, (option == 4) * (confirm + 1), x + checkPositionX, y + checkPositionY, 1, 1, 0, c_white, 1);
    
    // Exit
    draw_sprite_ext(sprExit, (option == 5) * (confirm + 1), x + exitPositionX, y + exitPositionY, 1, 1, 0, c_white, 1);
    
    // NOW draw itself
    draw_sprite(sprite_index, 0, x, y);
    
    //weapons
    var xff, yff, w, ammo, wname, cl;
    for(var p = 10; p &lt;= 21; p++)
    {
        xff = x + buttonPos[p, 0] + -28;
        yff = y + buttonPos[p, 1];
        w = global.weaponHotbar[p - 10];
        cl = (option == p);
        ammo = wepBarFills[p - 10];
        
        if global.weaponLocked[w] != 2 &amp;&amp; rHeldWeapon != p - 10
        {   //filled weapon slot
            //icon
            if cl
            {
                draw_sprite_ext(global.weaponIcon[w], 0, xff, yff - 8, 1, 1, 0, col[!cl, 2], 1);
                draw_sprite_ext(global.weaponIcon[w], 1, xff, yff - 8, 1, 1, 0, col[0, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 2, xff, yff - 8, 1, 1, 0, col[1, cl], 1);
                draw_sprite_ext(global.weaponIcon[w], 3, xff, yff - 8, 1, 1, 0, col[1, 2], cl);
            }
            else
                draw_sprite_ext(global.weaponIcon[w], 0, xff, yff - 8, 1, 1, 0, c_white, 1);
            
            if global.weaponLocked[w] == 0
            {
                //name
                draw_set_color(col[!cl, cl * 2]);
                
                wname = global.weaponName[w];
                if string_length(wname) &gt; 8
                {
                    dot = string_pos(" ", wname);
                    if (dot)
                        wname = string_insert(".", string_delete(wname, 2, dot - 1), 2);
                }
                
                draw_text(xff + 18, yff - 8, wname);
                draw_set_color(c_white);
                
                //ammo bar
                draw_sprite_ext(sprPauseMenuBarPrimary, ammo, xff + 18, yff, 1, 1, 0, col[0, cl * (1 + (p == 10))], 1);
                draw_sprite_ext(sprPauseMenuBarSecondary, ammo, xff + 18, yff, 1, 1, 0, col[1, cl * (1 + (p == 10))], 1);
                
                // Draw infinite energy mark over relevant bars
                if (global.infiniteEnergy[w])
                {
                    draw_sprite_ext(sprInfinityMark, 0, xff + 18 + 28, yff, 1, 1, 0, c_white, 1);
                    draw_sprite_ext(sprInfinityMark, 1, xff + 18 + 28, yff, 1, 1, 0, col[0, cl], 1);
                    draw_sprite_ext(sprInfinityMark, 2, xff + 18 + 28, yff, 1, 1, 0, col[1, cl], 1);
                }
            }
            else    //i.e. if global.weaponLocked[w] == 1
            {   //locked icon
                draw_sprite_ext(sprPauseMenuWeaponDisabled, 0, xff + 18, yff - 8, 1, 1, 0, c_white, 1);
            }
        }
        else if phase == 7
        {   //empty weapon slot
            //"icon"
            draw_sprite_ext(sprWeaponIconsBlank, 0, xff, yff - 8, 1, 1, 0, col[cl, 0], 1);
            //grey energy bar
            draw_sprite_ext(sprPauseMenuBarPrimary, ammo, xff + 18, yff, 1, 1, 0, col[0, 0], 1);
            draw_sprite_ext(sprPauseMenuBarSecondary, ammo, xff + 18, yff, 1, 1, 0, col[1, 0], 1);
        }
    }
    
    // mega man
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            drawPlayer(playerID, costumeID, 0, 0, other.x + 62, other.y + 18, 1, 1);
        }
    }
    
    // health
    draw_sprite_ext(sprPauseMenuBarPrimary, global.playerHealth[playerID], x + 35, y + 38, 1, 1, 0, col[0, 2], 1);
    draw_sprite_ext(sprPauseMenuBarSecondary, global.playerHealth[playerID], x + 35, y + 38, 1, 1, 0, col[1, 2], 1);
    
    // E-Tank
    draw_sprite_ext(sprETank, 2, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[0, option == 0], 1);
    draw_sprite_ext(sprETank, 4, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[1, option == 0], 1);
    
    draw_text(x + etankPositionX, y + etankPositionY + 18, zeroPad(global.eTanks, 2));
    
    // W-Tank
    draw_sprite_ext(sprWTank, 2, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[0, option == 1], 1);
    draw_sprite_ext(sprWTank, 4, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[1, option == 1], 1);
    
    draw_text(x + wtankPositionX, y + wtankPositionY + 18, zeroPad(global.wTanks, 2));
    
    // M-Tank
    draw_sprite_ext(sprMTank, 2, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[0, option == 2], 1);
    draw_sprite_ext(sprMTank, 4, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[1, option == 2], 1);
    
    draw_text(x + mtankPositionX, y + mtankPositionY + 18, zeroPad(global.mTanks, 2));
    
    // Bolts
    draw_sprite_ext(sprBoltBig, 0, x + 192, y + 16, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sprBoltBig, 1, x + 192, y + 16, 1, 1, 0, col[0, 1], 1);
    draw_sprite_ext(sprBoltBig, 2, x + 192, y + 16, 1, 1, 0, col[1, 1], 1);
    
    draw_text(x + 184, y + 33, zeroPad(global.bolts, 4));
    
    // Energy Elements
    draw_sprite_ext(sprEnergyElement, 0, x + 130, y + 15, 1, 1, 0, c_white, 1);
    
    draw_text(x + 125, y + 33, zeroPad(global.energyElements, 3));
    
    // Side Collectible
    draw_sprite_ext(sprKey, 0, x + 159, y + 16, 1, 1, 0, c_white, 1);
    
    draw_text(x + 155, y + 33, zeroPad(0, 3));
    
    //sort &amp; info buttons
    draw_sprite_ext(sprWeaponSort, (option == 6) + ((option == 7) * 2), x + rearrangePositionX, y + rearrangePositionY, 1, 1, 0, c_white, 1);
    
    // colored text overlays
    if (global.showColoredTextOverlays)
    {
        draw_sprite_ext(sprDot, 0, view_xview[0] + 16, view_yview[0], view_wview[0] - 32, view_hview[0], 0,
            make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
            global.coloredTextOverlaysOpacity / 255);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
