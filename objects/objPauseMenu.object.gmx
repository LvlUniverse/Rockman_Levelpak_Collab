<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPauseMenuNew</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = 0;

phase = 0; // 0: increasing the black rectangle's alpha

option = 10;
oldOption = 0;
//weaponOffset = 0;
//offsetTimer = -1;

// get currently visible weapons
/*
weaponVisibleN = 0;
for (var i = 0; i &lt;= global.totalWeapons; i++)
{
    if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
    {
        weaponVisible[weaponVisibleN++] = i;
    }
}
visibleWeapons = min(10, weaponVisibleN); // up to 10 visible

for (var i = 0; i &lt; weaponVisibleN; i++)
{
    if (global.weapon[0] == global.weaponHotbar[weaponVisible[i]])
    {
        option = i;
        oldOption = i;
    }
}
woption = i;

visibleWeapons = 10;
*/

oldWeapon = global.weapon[0];
resetWeapon = false; // Should we, after exiting the menu, reset our weapon to the weapon that was used before the pause menu was opened?

wtank = 0;
mtank = 0;

retryConfirm = 0;
exitConfirm = 0;
hotBarArrangeMode = false;

playerID = 0;
costumeID = 0;

// Stop charging
with (objMegaman)
{
    playerPalette();
}

// set these here. makes everyone's lives easier.

etankPositionX = 57;   buttonPos[0, 0] = etankPositionX; 
etankPositionY = 51;    buttonPos[0, 1] = etankPositionY; 
wtankPositionX = 85;   buttonPos[1, 0] = wtankPositionX;
wtankPositionY = 51;    buttonPos[1, 1] = wtankPositionY;
mtankPositionX = 30;   buttonPos[2, 0] = mtankPositionX;
mtankPositionY = 51;    buttonPos[2, 1] = mtankPositionY;  

optionsPositionX = 136; buttonPos[3, 0] = optionsPositionX + 11;
optionsPositionY = 208; buttonPos[3, 1] = optionsPositionY + 8;
checkPositionX = 158;   buttonPos[4, 0] = checkPositionX + 23;
checkPositionY = 208;   buttonPos[4, 1] = checkPositionY + 8;
exitPositionX = 204;    buttonPos[5, 0] = exitPositionX + 18;
exitPositionY = 208;    buttonPos[5, 1] = exitPositionY + 8;

infoPositionX = 18;    buttonPos[6, 0] = infoPositionX + 34;
infoPositionY = 205;    buttonPos[6, 1] = infoPositionY + 8;
rearrangePositionX = 88;    buttonPos[7, 0] = rearrangePositionX + 11;
rearrangePositionY = 205;    buttonPos[7, 1] = rearrangePositionY + 8;

//these buttons aren't anything. but, they could be!
buttonPos[8, 0] = undefined;
buttonPos[9, 0] = undefined;

//weapons at (38, 91), spaced 93x, 18y
for(var p = 0; p &lt;= 10; p++)
{
    buttonPos[p + 10, 0] = 38 + 28 + (floor(p / 6) * 92);
    buttonPos[p + 10, 1] = 99 + ((p mod 6) * 18);
}

arrowTimer = 20;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Can't control while a submenu is open
if (instance_exists(objOptionsMenu) || instance_exists(objDescriptionMenu))
{
    exit;
}

// do pause menu
switch (phase)
{
    // Fading out
    case 0:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1)
            {
                global.nextRoom = 0;
                other.visible = 1;
                other.phase = 1;
                showhealth = 0;
            }
        }
        break;
    
    // Fading in
    case 1:
        with (objGlobalControl)
        {
            if (fadeAlpha == 0)
            {
                other.phase = 2;
            }
        }
        event_user(0); // Moving the selection
        
        break;
    
    // Idle
    case 2:
        event_user(0); // Moving the selection
        
        //when fire is pressed...
        if (global.keySlidePressed[playerID])
            //and the option is a valid help option...
            &amp;&amp; (option &gt;= 10)
        {
            //open help menu
            with(instance_create(x, y, objDescriptionMenu))
            {
                option = other.option - 10;
                link = other;
            }
            playSFX(sfxElementGrab);
            exit;
        }
        
        // Select the weapon/tank
        if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
        {
            if (option &lt;= weaponVisibleN)
            {
                if (instance_exists(objMegaman.vehicle) &amp;&amp; option != 0)
                {
                    if (!objMegaman.vehicle.weaponsAllowed)
                    {
                        playSFX(sfxError);
                        exit;
                    }
                }
                
                global.nextRoom = -1;
                phase = 3;
                
                global.weapon[playerID] = global.weaponHotbar[weaponVisible[option]];
                playSFX(sfxMenuSelect);
            }
            else if (option == 0) // E-Tank
            {
                if (global.eTanks &amp;&amp; global.playerHealth[playerID] &lt; 28)
                {
                    option = 99; // Nothing selected
                    phase = 5;
                    wtank = 0;
                    mtank = 0;
                    global.eTanks -= 1;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == 1) // W-Tank
            {
                // Check if weapon energy actually needs filling
                var proceed;
                proceed = false;
                for (i = 0; i &lt; weaponVisibleN; i += 1)
                {
                    if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                    {
                        proceed = true;
                    }
                }
                
                if (global.wTanks &amp;&amp; proceed)
                {
                    option = 0; // Go back to weapon column
                    phase = 6;
                    mtank = 0;
                    wtank = 1;
                    global.wTanks -= 1;
                    playSFX(sfxMenuSelect);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == 2) // M-Tank
            {
                if (global.mTanks &gt; 0) // Check if health or weapon energy actually needs filling
                {
                    var proceed = false;
                    for (i = 0; i &lt; weaponVisibleN; i += 1)
                    {
                        if (ceil(global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]]) &lt; 28)
                        {
                            proceed = true;
                        }
                    }
                    
                    if (ceil(global.playerHealth[playerID]) &lt; 28)
                    {
                        proceed = true;
                    }
                    
                    if (proceed) // If proceed is still false after the past calculations, it seems there is nothing to fill
                    {
                        option = 99; // Nothing selected
                        phase = 5;
                        mtank = 1;
                        wtank = 0;
                        global.mTanks -= 1;
                        eTankTimer = 0;
                        loopSFX(sfxEnergyRestore);
                    }
                    else
                    {
                        playSFX(sfxError);
                    }
                }
                else
                {
                    playSFX(sfxError);
                }
            }
            else if (option == 3) // Options
            {
                instance_create(x, y, objOptionsMenu);
                playSFX(sfxMenuSelect);
                exit;
            }
            else if (option == 4) // Retry
            {
                if (!retryConfirm)
                {
                    retryConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
            else if (option == 5) // Exit
            {
                if (!exitConfirm)
                {
                    exitConfirm = true;
                    playSFX(sfxMenuSelect);
                    exit;
                }
            }
        }
        
        // Confirming exit
        if (exitConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == 5)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    returnFromLevel();
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                exitConfirm = false;
            }
        }
        
        // Confirming retry
        if (retryConfirm &amp;&amp; !global.nextRoom)
        {
            if (option == 4)
            {
                if (global.keyJumpPressed[playerID]
                    || global.keyPausePressed[playerID])
                {
                    global.nextRoom = room;
                    playSFX(sfxMenuSelect);
                }
            }
            else
            {
                retryConfirm = false;
            }
        }
        
        break;
    
    // Fading out
    case 3:
        with (objGlobalControl)
        {
            if (fadeAlpha == 1 &amp;&amp; global.nextRoom != 0)
            {
                showhealth = 1;
                with (other)
                {
                    if (resetWeapon)
                    {
                        global.weapon[playerID] = oldWeapon;
                        with (objMegaman)
                        {
                            playerPalette();
                        }
                    }
                    
                    if (global.weapon[playerID] != oldWeapon)
                    {
                        with (prtPlayerProjectile)
                        {
                            instance_destroy();
                        }
                    }
                    
                    global.nextRoom = 0;
                    visible = 0;
                }
            }
            else if (fadeAlpha == 0 &amp;&amp; global.nextRoom == 0)
            {
                with (other)
                {
                    audio_resume_all();
                    instance_destroy();
                    global.frozen = 0;
                }
            }
        }
        
        break;
    
    // E/M-Tank restoring health
    case 5:
        eTankTimer += 1;
        if (eTankTimer &gt;= 3)
        {
            eTankTimer = 0;
            
            var proceed;
            proceed = false;
            
            // Fill selected weapon w/ W Tank
            if (wtank)
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] = min(28,
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] + 1);
                    proceed = true;
                }
            }
            
            // Fill all weapons - M-Tank only
            if (mtank)
            {
                for (i = 1; i &lt; weaponVisibleN; i += 1)
                {
                    if (global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] &lt; 28)
                    {
                        global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] = min(28,
                            global.ammo[playerID, global.weaponHotbar[weaponVisible[i]]] + 1);
                        proceed = true;
                    }
                }
            }
            
            // Fill health
            if ((global.playerHealth[playerID] &lt; 28) &amp;&amp; (!wtank))
            {
                global.playerHealth[playerID] = min(28,
                    global.playerHealth[playerID] + 1);
                proceed = true;
            }
            
            if (!proceed)
            {
                eTankTimer = 0;
                phase = 2;
                if (!wtank)
                {
                    option = oldOption;
                    global.weapon[playerID] = oldWeapon;
                    with (objMegaman)
                    {
                        playerPalette();
                    }
                }
                
                audio_stop_sound(sfxEnergyRestore);
            }
        }
        
        break;
    
    // W-Tank weapon selection
    case 6:
        event_user(0); // Moving the selection
        
        if (option &gt; 0 &amp;&amp; option &lt; weaponVisibleN)
        {
            if (global.keyJumpPressed[playerID] || global.keyPausePressed[playerID])
            {
                if (global.ammo[playerID, global.weaponHotbar[weaponVisible[option]]] &lt; 28)
                {
                    phase = 5;
                    eTankTimer = 0;
                    loopSFX(sfxEnergyRestore);
                }
                else
                {
                    playSFX(sfxError);
                }
            }
        }
        
        break;
}

// update stored player sprite
if (instance_exists(objMegaman))
{
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            other.costumeID = costumeID;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move cursor

//takes buttonPos, varDir, dir, cursorPos, option. outputs to option

nearestOption = -1;
var closePoints;
var nearestClosePoints = 999999;

for(var p = 0; p &lt; array_height_2d(buttonPos); p++)
{
    //non-options aren't options
    if buttonPos[p, 0] == undefined
        continue;

    //draw a plane cutting away all options that aren't in the direction of movement
    if ((buttonPos[p, dir] - cursorPos[dir]) * varDir[dir])
    //offset the plane by the difference in position perpindicular to movement
    /*
    this is to keep it from selecting options that are just slightly further
    to the right than the current one, but very far away vertically,
    that may get selected if you push the edges of the menu
    */
        - abs(cursorPos[!dir] - buttonPos[p, !dir]) / 1.4 &gt; 0
    {
        //buttons get points. more points = bad
        closePoints = abs(cursorPos[dir] - buttonPos[p, dir]);
        //the perpindicular direction is accounted for, but deprioritized
        closePoints += abs(cursorPos[!dir] - buttonPos[p, !dir]) * 7;
        
        //if current button is closer than previous record-setter, replace it
        if (closePoints &lt; nearestClosePoints)
        {
            nearestOption = p;
            nearestClosePoints = closePoints;
        }
    }
}

//-1 means it did not find an option in that direction
if !(nearestOption == -1 || nearestOption == option)
{
    option = nearestOption;
    playSFX(sfxWeaponSwitch);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///moving between options
hotBarArrangeMode = (global.keyShoot[playerID]) * (hotBarArrangeMode + 1);

var xDir = (global.keyRightPressed[playerID] - global.keyLeftPressed[playerID]);

var yDir = (global.keyDownPressed[playerID] - global.keyUpPressed[playerID]);

cursorPos[0] = buttonPos[option, 0];
cursorPos[1] = buttonPos[option, 1];
varDir[0] = xDir;
varDir[1] = yDir;

if (yDir != 0)
{
    //vertical movement while NOT on the weapon list
    dir = 1;
    event_user(5);
    
    //if scrolled off the menu, try again from the other side
    if nearestOption = -1
    {
        cursorPos[1] -= view_hview * yDir;
        event_user(5);
    }
}

if (xDir != 0 &amp;&amp; phase != 6)    //same as above
{
    dir = 0;
    event_user(5);
    
    if nearestOption = -1
    {
        cursorPos[0] -= view_wview * xDir;
        event_user(5);
    }
}

////TODO: this should only work while in rearrange mode
// L + R resets weapon order

// it only checks for one pressed because if it checked both you'd have to press both
// buttons on the same frame, but if you could just hold the two buttons you would get
// a very loud screeching noise every time you reset + it'd be easier to accidentally
// sort
if ((global.keyWeaponSwitchLeft[playerID] &amp;&amp; global.keyWeaponSwitchRightPressed[playerID])
    || (global.keyWeaponSwitchLeftPressed[playerID] &amp;&amp; global.keyWeaponSwitchRight[playerID]))
{
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if global.weaponHotbar[i] != i
        {
            global.weaponHotbar[i] = i;
            playSFX(sfxMenuSelect);
        }
    }
    
    weaponVisibleN = 0;
    for (var i = 0; i &lt;= global.totalWeapons; i++)
    {
        if (global.weaponLocked[global.weaponHotbar[i]] &lt; 2)
        {
            weaponVisible[weaponVisibleN++] = i;
        }
    }
    visibleWeapons = min(10, weaponVisibleN); // up to 10 visible
    oldOption = 0;
}

// Set weapon
global.weapon[playerID] = 0;
if (option &gt;= 10)
{
    global.weapon[playerID] = global.weaponHotbar[option - 10];
}

with (objMegaman)
{
    playerPalette();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// center in screen on nonstandard resolutions
x = view_xview + (view_wview[0] - 256) / 2;
y = view_yview + (view_hview[0] - 224) / 2;

// Menu
if (phase != 0)
{
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
    draw_clear(c_black);
    
    var col;
    col[0, 0] = global.nesPalette[0];
    col[1, 0] = global.nesPalette[13];
    col[0, 1] = global.primaryCol[0];
    col[1, 1] = global.secondaryCol[0];
    col[0, 2] = make_color_rgb(255, 228, 164);
    col[1, 2] = c_white;
    
    // these actually go 'under' the pause menu, so they go before drawSelf.
    
    // Options
    draw_sprite_ext(sprGotoOptions, (option == 3), x + optionsPositionX, y + optionsPositionY, 1, 1, 0, c_white, 1);
    
    // Checkpoint
    draw_sprite_ext(sprGotoCheckpoint, (option == 4) + retryConfirm * 2, x + checkPositionX, y + checkPositionY, 1, 1, 0, c_white, 1);
    
    // Exit
    draw_sprite_ext(sprExit, (option == 5) + exitConfirm * 2, x + exitPositionX, y + exitPositionY, 1, 1, 0, c_white, 1);
    
    // NOW draw itself
    draw_sprite(sprite_index, 0, x, y);
    
    //weapons
    var xff, yff, w, ammo, wname, cl;
    for(var p = 10; p &lt;= 20; p++)
    {
        xff = x + buttonPos[p, 0] + -28;
        yff = y + buttonPos[p, 1];
        w = global.weaponHotbar[p - 10];
        cl = (option == p);
        
        //icon
        if cl
        {
            draw_sprite_ext(global.weaponIcon[w], 0, xff, yff - 8, 1, 1, 0, col[!cl, 2], 1);
            draw_sprite_ext(global.weaponIcon[w], 1, xff, yff - 8, 1, 1, 0, col[0, cl], 1);
            draw_sprite_ext(global.weaponIcon[w], 2, xff, yff - 8, 1, 1, 0, col[1, cl], 1);
            draw_sprite_ext(global.weaponIcon[w], 3, xff, yff - 8, 1, 1, 0, col[1, 2], cl);
        }
        else
            draw_sprite_ext(global.weaponIcon[w], 0, xff, yff - 8, 1, 1, 0, c_white, 1);
        
        if (!global.weaponLocked[w])
        {
            // Drawing ammo bars
            ammo = ceil(global.playerHealth[playerID] * (p == 10) + global.ammo[playerID, w] * (p != 10));
            
            draw_sprite_ext(sprPauseMenuBarPrimary, ammo, xff + 18, yff, 1, 1, 0, col[0, cl * (1 + (p == 10))], 1);
            draw_sprite_ext(sprPauseMenuBarSecondary, ammo, xff + 18, yff, 1, 1, 0, col[1, cl * (1 + (p == 10))], 1);
            
            // Draw infinite energy mark over relevant bars
            if (global.infiniteEnergy[w])
            {
                draw_sprite_ext(sprInfinityMark, 0, xff + 18 + 28, yff, 1, 1, 0, c_white, 1);
                draw_sprite_ext(sprInfinityMark, 1, xff + 18 + 28, yff, 1, 1, 0, col[0, cl], 1);
                draw_sprite_ext(sprInfinityMark, 2, xff + 18 + 28, yff, 1, 1, 0, col[1, cl], 1);
            }
            
            // Name
            draw_set_color(col[!cl, (cl * 2) - (cl * !(hotBarArrangeMode mod 8 &lt; 4))]);
            
            wname = global.weaponName[w];
            if string_length(wname) &gt; 8
            {
                dot = string_pos(" ", wname);
                if (dot)
                    wname = string_insert(".", string_delete(wname, 2, dot - 1), 2);
            }
            
            draw_text(xff + 18, yff - 8, wname);
            draw_set_color(c_white);
        }
        else // draw the disabled stuff
        {
            draw_sprite_ext(sprPauseMenuWeaponDisabled, 0, 18, yOff, 1, 1, 0, c_white, 1);
        }
    }
    
    // mega man
    with (objMegaman)
    {
        if (playerID == other.playerID)
        {
            drawPlayer(playerID, costumeID, 0, 0, other.x + 62, other.y + 18, 1, 1);
        }
    }
    
    // health
    draw_sprite_ext(sprPauseMenuBarPrimary, global.playerHealth[playerID], x + 35, y + 38, 1, 1, 0, col[0, 2], 1);
    draw_sprite_ext(sprPauseMenuBarSecondary, global.playerHealth[playerID], x + 35, y + 38, 1, 1, 0, col[1, 2], 1);
    
    // E-Tank
    draw_sprite_ext(sprETank, 2, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[0, option == 0], 1);
    draw_sprite_ext(sprETank, 4, x + etankPositionX, y + etankPositionY, 1, 1, 0, col[1, option == 0], 1);
    
    draw_text(x + etankPositionX, y + etankPositionY + 18, zeroPad(global.eTanks, 2));
    
    // W-Tank
    draw_sprite_ext(sprWTank, 2, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[0, option == 1], 1);
    draw_sprite_ext(sprWTank, 4, x + wtankPositionX, y + wtankPositionY, 1, 1, 0, col[1, option == 1], 1);
    
    draw_text(x + wtankPositionX, y + wtankPositionY + 18, zeroPad(global.wTanks, 2));
    
    // M-Tank
    draw_sprite_ext(sprMTank, 2, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[0, option == 2], 1);
    draw_sprite_ext(sprMTank, 4, x + mtankPositionX, y + mtankPositionY, 1, 1, 0, col[1, option == 2], 1);
    
    draw_text(x + mtankPositionX, y + mtankPositionY + 18, zeroPad(global.mTanks, 2));
    
    // Bolts
    draw_sprite_ext(sprBoltBig, 0, x + 192, y + 16, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sprBoltBig, 1, x + 192, y + 16, 1, 1, 0, col[0, 1], 1);
    draw_sprite_ext(sprBoltBig, 2, x + 192, y + 16, 1, 1, 0, col[1, 1], 1);
    
    draw_text(x + 184, y + 33, zeroPad(global.bolts, 4));
    
    // Energy Elements
    draw_sprite_ext(sprEnergyElement, 0, x + 130, y + 15, 1, 1, 0, c_white, 1);
    
    draw_text(x + 125, y + 33, zeroPad(global.energyElements, 3));
    
    // Side Collectible
    draw_sprite_ext(sprKey, 0, x + 159, y + 16, 1, 1, 0, c_white, 1);
    
    draw_text(x + 155, y + 33, zeroPad(0, 3));
    
    //sort &amp; info buttons
    draw_sprite_ext(sprWeaponSort, (option == 6) + ((option == 7) * 2), x + infoPositionX, y + infoPositionY, 1, 1, 0, c_white, 1);
    
    // colored text overlays
    if (global.showColoredTextOverlays)
    {
        draw_sprite_ext(sprDot, 0, view_xview[0] + 16, view_yview[0], view_wview[0] - 32, view_hview[0], 0,
            make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
            global.coloredTextOverlaysOpacity / 255);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
