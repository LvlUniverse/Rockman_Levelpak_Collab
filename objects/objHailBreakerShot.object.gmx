<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprHailBreakerShot</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtEntity</parentName>
  <maskName>mskDischargeDash1</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///the ice balls that hail breaker releases
event_perform_object(prtPlayerProjectile, ev_create, 0);

bulletLimitCost = 0;

contactDamage = -2;
penetrate = 3;
pierces = 2;

despawnRange = -1;

particleTimer = undefined;

angle = 0;
dist = 0;

mySpeed = 11;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if entityCanStep()
{
    //move
    dist += 3;
    angle += mySpeed / 100;
    x = xstart + (sin(angle) * dist);
    y = ystart + (-cos(angle) * dist);
    
    //release particles
    if (particleTimer != undefined) &amp;&amp; (particleTimer++ mod 8 == 2)
        instance_create(x, y, objAnimatedParticle);
    
    //create ice
    mask_index = mskPreciseDot;
    with(objWater)
    {
        //check 1: object is even vaguely touching the top of this water object
        if collision_rectangle(bbox_left, bbox_top - 32, bbox_right, bbox_top + 48, 
        other, false, true) != noone
        {
            //determine where the ice will go
            var icex = bbox_left + (floor((other.x - bbox_left) / 16) * 16);
            icex = clamp(icex, bbox_left, bbox_right - 16);
            //check 2: the top of this water object is the surface of the water,
            //and isn't already iced
            if !collision_rectangle(icex, bbox_top, icex + 16, bbox_top - 16, 
            objWater, false, true)
            &amp;&amp; !collision_point(icex + 8, bbox_top + 8, objHailBreakerTempIce, false, true)
            {
                //create ice
                var i = instance_create(icex, bbox_top, objHailBreakerTempIce);
                if instance_exists(i)
                {
                    i.xOffset = icex - bbox_left;
                    i.waterObj = id;
                }
            }
        }
    }
    //restore lifeTimer on old ice
    with(objHailBreakerTempIce)
    {
        if place_meeting(x, y, other)
            lifeTimer = 360;
    }
    mask_index = mskDischargeDash1;
    
    //despawn if completely off screen edges
    if xstart + dist + -80  &gt; view_xview + view_wview
        &amp;&amp; xstart + -dist + 80 &lt; view_xview
        &amp;&amp; ystart + dist + -80 &gt; view_yview + view_hview
        &amp;&amp; ystart + -dist + 80 &lt; view_yview
    {
        instance_destroy();
        exit;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///never ever respawn
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///freeze enemies instead of doing damage
if (other.faction == faction)
    exit;

if (global.damage == -2)
{
    global.damage = 0;
    if (other.boss &gt; 0)
    {
        global.damage = 1;
    }
}

with (other)
{
    if (canIce)
        entityIceFreeze(240, false, true, 0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///die when deflected
//since the hitbox is much bigger than the visual, let's be a bit lenient with deflection
if position_meeting(x, y, other)
{
    playSFX(sfxReflect);
    instance_create(x, y, objExplosion);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
