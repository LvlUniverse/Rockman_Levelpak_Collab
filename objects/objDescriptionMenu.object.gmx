<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDescriptionMenuBG</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2002</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.nextRoom = -1;
visible = false;

if (!instance_number(object_index) &gt; 1)
{
    instance_destroy();
    visible = false;
    exit;
}

phase = 0;
link = 0;

option = 0;

animTimer = 0;
quickScrollTimer = 25;

vScroll = 0;
vquickScrollTimer = 25;

descW = 8 * 24;
descH = 8 * 16;
textBoxSurface = surface_create(descW, descH);
thisDescHeight = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if no pause menu is open, leave and spit error
if (!instance_exists(link))
{
    printErr("Description menu exists, but not pause menu!")
    instance_destroy();
    exit;
}

animTimer++;

switch (phase)  //copied from pause menu
{
    // Fading out
    case 0:
        if (objGlobalControl.fadeAlpha == 1)
        {
            global.nextRoom = 0;
            objGlobalControl.showhealth = 0;
            visible = 1;
            phase++;
        }
        break;
    
    // Fading in
    case 1:
        if (objGlobalControl.fadeAlpha == 0)
            phase++;
        break;
    
    // Doing menu selections
    case 2:
        //exit menu with many buttons
        if global.keyJumpPressed[0] || global.keyShootPressed[0] || global.keyPausePressed[0] || global.keySlidePressed[0]
        {
            phase++;
            playSFX(sfxElementGrab);
            break;
        }
        
        var xDir = (global.keyRight[0] - global.keyLeft[0]);
        //horizontal scroll &amp; quickscroll
        var doScroll = false;
        if (xDir != 0)
        {
            if (quickScrollTimer == 0) || (quickScrollTimer == 25)
            {
                doScroll = true;
                if (quickScrollTimer == 0)
                    quickScrollTimer = 8;
            }
            quickScrollTimer--;
        }
        else
            quickScrollTimer = 25;
        
        //what to do when scrolling
        if (doScroll)
        {
            //scroll until a non-hidden weapon is encountered (locked weps are fine)
            var ifi = true;
            while (ifi || global.weaponLocked[global.weaponHotbar[option]] == 2)
            {
                ifi = false;
                option += xDir;
                //wrapping
                if option &lt; 0
                    option += 12;
                if (option &gt; 11)
                    option -= 12;
            }
            
            playSFX(sfxWeaponSwitch);
                
            //moving around in here moves around in pause menu, too!
            link.option = option + 10;
            //handle weapon colors
            with(link)
            {
                global.weapon[playerID] = global.weaponHotbar[other.option];
                with(objMegaman)
                    playerPalette();
            }
            //reset vertical scroll
            vScroll = 0;
        }
        
        //vertical scroll
        var yDir = (global.keyDown[0] - global.keyUp[0]);
        doScroll = false;
        if (yDir != 0) &amp;&amp; (quickScrollTimer == 25)//the horizontal timer
        {
            if vquickScrollTimer == 8
                doScroll = true;
            if (vquickScrollTimer == 0)
                vquickScrollTimer = 9;
            vquickScrollTimer--;
        }
        else
            vquickScrollTimer = 8;
        
        if doScroll 
            &amp;&amp; (vScroll + yDir &gt;= 0) 
            &amp;&amp; (vScroll + yDir &lt;= thisDescHeight - 16)
        {
            vScroll += yDir * doScroll;
            if yDir &gt; 0
                playSFX(sfxMenuScrollDown);
            else
                playSFX(sfxMenuScrollUp);
        }
        break;
    
    // Fading out
    case 3:
        global.nextRoom = -1;
        if (objGlobalControl.fadeAlpha == 1)
        {
            global.nextRoom = 0;
            visible = 0;
            phase++;
        }
        break;
    
    // Fading back in to pause menu
    case 4:
        if objGlobalControl.fadeAlpha == 0
        {
            global.frozen = true;
            instance_destroy();
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);

// center display on non-standard resolutions
drawXPosition = view_xview[0] + view_wview[0] / 2 - 128;
drawYPosition = view_yview[0] + view_hview[0] / 2 - 112;

// draw menu bg
draw_sprite(sprite_index, 0, drawXPosition, drawYPosition);

draw_set_halign(fa_left);
draw_set_valign(fa_top);

//draw_text(x, y, string(option))//debug: draw option

var drawTitle = "error";
var drawDesc = "nothing";
var drawStats = "-#-#-#-";

//get weapon info from global weapon list
var wep, drawTitle, drawDesc, drawStats;
var wep = global.weapon[0];
drawTitle = global.weaponName[wep];

//weapon descriptions are only relevant here, so here they are stored
switch(global.weaponObject[wep])
{
        case objBusterShot:
        drawStats = "1, 3#5#3#0";
        drawDesc = " You fire bullets that 
fly straight. You can 
also charge up energy by 
holding down FIRE, for a 
shot that is larger, 
stronger, and pierces 
enemies it destroys.

 Thanks to solar energy, 
this can be fired 
infinitely."
//sorry. the indenting would get counted as a part of the string
        break;

    case objNekoClaw:
        drawStats = "1#8#1#1/2";
        drawDesc = " A large hydaulic 
powered cat paw that 
pierces shields, and can 
retrieve minor items.

 It can be aimed in 
seven directions, but 
its range is limited.

 If you hold down FIRE, 
it will fire again as 
soon as it returns. If 
you are very close to a
foe, it will fire 
rapidly for huge damage.";
        break;
    
    case objDischargeDash:
        drawStats = "2#4.5#1#2";
        drawDesc = " An electric barrier 
that can be charged by 
absorbing shots and 
weak enemies. Once 
charged, you can press
FIRE to perform an 
invincible dash, even 
in the air.

 The barrier can hold 
up to three charges, but
it will still guard you
even if it's fully 
charged.";
        break;
    
    case objTinTrooper:
        drawStats = "2#1#3#1.5";
        drawDesc = " A small metal soldier 
that walks forward and 
explodes upon contact 
with an enemy.

 The soldier can jump 
over small obstacles and
gaps, can fit in narrow 
passageways, and will 
turn around at walls.";
        break;
    
    case objFlameSweeper:
        drawStats = "3#7#1#4";
        drawDesc = " Fires a small, 
harmless fireball. If 
you press FIRE again, 
the small fireball 
detonates into a strong
wave of flame that goes
the opposite direction.

 The small fireball can 
be angled up and down. 
This doesn't affect the 
direction of the return 
wave.

 The return wave is 
weaker if detonated 
directly on an enemy.";
        break;
    
    case objSiphonTopaz:
        drawStats = "2, 4#1#1#2";
        drawDesc = " A large topaz that 
moves in a narrow arc. 
If the topaz hits an 
enemy, it will bounce 
upwards, and steal some 
health at the cost of
one point of energy.

 If you hit multiple 
times with one shot, it 
will deal extra damage 
and steal more health.

 This can be fired even 
if the shot limit has 
been reached, at the 
cost of the existing 
shot.";
        break;
    
    case objTyphoonFunnel:
        drawStats = "1#-#1#2";
        drawDesc = " A tall, narrow tropical 
storm. While held, the 
storm will follow your 
movement and slow your 
fall.

 When you land on the 
ground or release the 
FIRE button, the storm 
is released: it keeps 
moving in the direction 
it was going when it was 
released, and slowly
parts from its center.

 The typhoon becomes 
stronger when it sucks 
up water, and allows you 
to move freely in water 
at an energy cost.";
        break;
    
    case objHailBreaker:
        drawStats = "0#3#1#5";
        drawDesc = " A torrent of ice that 
freezes enemies and 
water all around you.
 
 Frozen enemies can be 
walked on without harm.

 The ice persists even 
when you switch weapons.";
        break;
    
    case objBlockTurret:
        drawStats = "1#5#1#8";
        drawDesc = " A rapid-firing turret 
that can be picked up or 
put down by pressing the 
FIRE button.

 The turret can be stood 
on, and you can adjust 
its height by landing on 
it, or with UP and DOWN 
while standing on it.";
        break;
    
    case objTeleportPhaser:
        drawStats = "1#4#1#3";
        drawDesc = " You charge up energy, 
and then release it to 
teleport upwards.

 You are invulnerable 
and deal minor damage to 
foes while teleporting.";
        break;
    
    case objItem4:
        drawStats = "12#-#1#4";
        drawDesc = " A large battle mech 
that can walk on spikes 
and crush foes by 
landing on them.

 The mech is invincible, 
but its rider is still 
vulnerable.

 The mech has a gun, 
though it is quite weak.";
        break;
    
    case objSkeletuppinPakkajoe:
        drawStats = "!!!!!#Yes#9999999#WOW";
        drawDesc = "Debug weapon.#Ends all life.####################sand undetrale"
        break;
    
    default:
        drawStats = "?#?#?#?";
        drawDesc = "No description provided.";
        break;
}
thisDescHeight = string_height(drawDesc) / 8;

//draw weapon icon
draw_sprite_ext(global.weaponIcon[wep], 0, x + 24, y + 8, 1, 1, 0, make_color_rgb(255, 228, 164), 1);
draw_sprite_ext(global.weaponIcon[wep], 1, x + 24, y + 8, 1, 1, 0, global.primaryCol[0], 1);
draw_sprite_ext(global.weaponIcon[wep], 2, x + 24, y + 8, 1, 1, 0, global.secondaryCol[0], 1);
draw_sprite_ext(global.weaponIcon[wep], 3, x + 24, y + 8, 1, 1, 0, c_white, 1);

//description
if !surface_exists(textBoxSurface)
    textBoxSurface = surface_create(descW, descH);
surface_set_target(textBoxSurface);
draw_clear_alpha(c_black, 0);
draw_text(0, vScroll * -8, drawDesc);
surface_reset_target();
draw_surface(textBoxSurface, x + 32, y + 40);

//other text
draw_text(x + 48, y + 12, drawTitle);
draw_text(x + 32, y + 184, "DAMAGE#SPEED#SHOT LIMIT#COST");
draw_set_halign(fa_right);
draw_text(x + 216, y + 184, drawStats);
draw_set_halign(fa_left);

//horizontal arrows
var arrowanim = ceil((animTimer mod 29 + 1) / 10);
draw_sprite(sprArrow, 0, x + 27 + -arrowanim, y + 105);
draw_sprite(sprArrow, 1, x + 229 + arrowanim, y + 105);

//vertical arrows
if (vScroll &gt; 0)
    draw_sprite(sprArrow, 2, x + 228, y + 44 + -arrowanim);
if (vScroll &lt; thisDescHeight - 16)
    draw_sprite(sprArrow, 3, x + 228, y + 164 + arrowanim);

// colored text overlays
if (global.showColoredTextOverlays)
{
    draw_sprite_ext(sprDot, 0, view_xview[0] + 16, view_yview[0], view_wview[0] - 32, view_hview[0], 0,
        make_color_rgb(global.coloredTextOverlaysRed, global.coloredTextOverlaysGreen, global.coloredTextOverlaysBlue),
        global.coloredTextOverlaysOpacity / 255);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
