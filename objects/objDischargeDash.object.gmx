<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDischargeDashOrbital</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>prtPlayerProjectile</parentName>
  <maskName>mskDischargeDash2</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

bulletLimitCost = 1;

contactDamage = 1;

penetrate = 1;
pierces = 2;

despawnRange = -1; // don't be despawned by scrolling offscreen
shiftVisible = true;

rotTimer = 0;
rotRadius = 0;
targetRotRadius = 20;
animTimer = 0;
we = 0;
antiRapidBuffer = 0;

bufferRecharge = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if !global.frozen || instance_exists(objSectionSwitcher)
{
    //track parent
    if (instance_exists(parent))
    {
        we = global.ammo[parent.playerID, global.weaponID[? objDischargeDash]];
        //track player's movement
        x = spriteGetXCenterObject(parent);
        y = spriteGetYCenterObject(parent);
        image_yscale = parent.image_yscale;
        
        //celeste-style dash recovery if energy is infinite
        
        if global.infiniteEnergy[global.weaponID[? objDischargeDash]] 
            &amp;&amp; parent.dischargeDashCharges == 0
            &amp;&amp; !instance_exists(objDischargeDashDash)
        {
            if parent.ground &amp;&amp; !bufferRecharge
                bufferRecharge = true;
            
            if bufferRecharge &amp;&amp; parent.iFrames == 0
            {
                parent.dischargeDashCharges = 1;
                bufferRecharge = false;
            }
        }
        else
            bufferRecharge = false;
        
        
        //    animations    //
        //basic anim timer
        animTimer++;
        //rotating animation
        if instance_exists(objDischargeDashDash)
            rotTimer += 0.3;
        else if we &gt; 0
            rotTimer += 0.1;
        //flickering animation when out of weapon energy
        if (we &lt;= 0)
            visible = !visible;
        else
            visible = true;
        //size animations
        if instance_exists(objDischargeDashDash) //becomes slightly smaller for dashes
            targetRotRadius = 14;   
        else if (we &lt;= 0) &amp;&amp; (parent.dischargeDashCharges &lt;= 0)
        {   //shrinks to nothing when energy has run out
            targetRotRadius = 0;
            if (rotRadius == 0)
            {
                instance_destroy();
                exit;
            }
        }
        else //normal size
            targetRotRadius = 20;
        //real radius approaches target radius 'gradually'
        var u = targetRotRadius - rotRadius;
        rotRadius += max(abs(u) / 3, min(0.5, u)) * sign(u);
        //    end of animations    //
        
        
        //change hitbox based on size
        if rotRadius &lt;= 14.5
            mask_index = mskDischargeDash2;
        else
            mask_index = mskDischargeDash1;
        
        //timer goes down
        antiRapidBuffer--;
    }
    else
    {   //die if player dies
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="prtEnemyProjectile">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///absorb enemy projectiles

if canDamage &amp;&amp; !other.dead &amp;&amp; (global.ammo[playerID, global.weaponID[? objDischargeDash]] &gt; 0)
{
    //special case for electric hazards, making them harmless but not destroying them, regardless of reflectability
    if other.sprite_index == sprElecThunder || other.sprite_index == sprElectricGabyoallCurrent
    {
        if other.contactDamage != 0
        {
            other.contactDamage = 0;
            if parent.dischargeDashCharges &lt; 3
            {
                parent.dischargeDashCharges++;
                animTimer = 0;
                var fx = instance_create(bboxGetXCenter(), bboxGetYCenter(), objSingleLoopEffect);
                fx.image_speed = 1/3;
                fx.sprite_index = spr4MICrit;
                playSFX(sfxEnkerCharge);
            }
        }
        exit;
    }
    switch (other.reflectable)
    {
        case -1:
        case 1:
            if instance_exists(parent)
            {
                //if less than 3 charges, delete projectile for charge
                if parent.dischargeDashCharges &lt; 3
                {   
                    parent.dischargeDashCharges++;
                    animTimer = 0;
                    playSFX(sfxEnkerCharge);
                    with (other)
                    {
                        instance_destroy();
                        var fx = instance_create(bboxGetXCenter(), bboxGetYCenter(), objSingleLoopEffect);
                        fx.image_speed = 1/3;
                        fx.sprite_index = spr4MICrit;
                    }
                }
                else
                {
                    //else, smash projectile
                    playSFX(sfxEnemyHit);
                    with (other)
                    {
                        instance_create(bboxGetXCenter(), bboxGetYCenter(), objExplosion);
                        instance_destroy();
                    }
                }
                //drain weapon energy in either case
                if antiRapidBuffer &lt;= 0
                    global.ammo[playerID, global.weaponID[? objDischargeDash]] -= 1 / (global.energySaver + 1);
                else
                    global.ammo[playerID, global.weaponID[? objDischargeDash]] -= 0.2 / (global.energySaver + 1);
                
                antiRapidBuffer = 4;
            }
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="24">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///While equipped...

//when the player presses shoot...
if global.keyShootPressed[playerID] &amp;&amp; !playerIsLocked(PL_LOCK_SHOOT)
{
    //if no barrier, summon barrier for 4 weapon energy
    if !instance_exists(objDischargeDash) 
    {
        if global.ammo[playerID, global.weaponID[? objDischargeDash]] &gt; 2 //if fired from 2 energy, it can't soak up any shots at all and would die instantly
        {
            fireWeapon(0, 0, objDischargeDash, 1, 2, 2, 0);
            dischargeDashCharges = 0;
            playSFX(sfxElectricShot);
        }
    }
    else
    {   //if barrier exists, try to perform dash at the cost of a charge
        if (dischargeDashCharges &gt; 0)
        {
            //dismount a ladder if we're on one
            if(climbing)
            {
                climbing = false;
                climbLock = lockPoolRelease(climbLock);
                shootStandStillLock = lockPoolRelease(shootStandStillLock);
                if xDir != 0
                    image_xscale = sign(xDir);
                else
                    image_xscale = ladderXScale;
            }
            
            var a = instance_create(x, y, objDischargeDashDash);
            a.image_xscale = image_xscale;
            dischargeDashCharges--;
            canMinJump = false;
        }
    }
}

//colormao when dashing
if instance_exists(objDischargeDashDash)
{
    chargeTimer++;
    switch (floor((chargeTimer / 3) mod 3))
    {
        case 0:
            global.primaryCol[playerID] = global.weaponSecondaryColor[global.weapon[playerID]];
            global.secondaryCol[playerID] = c_black;
            global.outlineCol[playerID] = global.weaponPrimaryColor[global.weapon[playerID]];
            break;
        case 1:
            global.primaryCol[playerID] = c_black;
            global.secondaryCol[playerID] = global.weaponPrimaryColor[global.weapon[playerID]];
            global.outlineCol[playerID] = global.weaponSecondaryColor[global.weapon[playerID]];
            break;
        case 2:
            global.primaryCol[playerID] = global.weaponPrimaryColor[global.weapon[playerID]];
            global.secondaryCol[playerID] = global.weaponSecondaryColor[global.weapon[playerID]];
            global.outlineCol[playerID] = c_black;
            break;
    }
}
else if chargeTimer &gt; 0
{
    chargeTimer = 0;
    playerPalette();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="23">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///don't hit enemies with more than 1 hp

if instance_exists(parent) &amp;&amp; (global.ammo[playerID, global.weaponID[? objDischargeDash]] &gt; 0)
{
    //special case: don't absorb even 1hp enemies if we're dashing and the shield is already fully charged
    if instance_exists(objDischargeDashDash) &amp;&amp; (parent.dischargeDashCharges &gt;= 3)
        global.damage = -1;
    //if not 1hp enemy, does nothing
    else if other.healthpointsStart &gt; 1
        global.damage = -1;
}
else    //no damage if out of energy or parent is dead
    global.damage = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Weapon setup
weaponSetup("DISCHARGE DASH", 
    make_color_rgb(216, 0, 204), 
    make_color_rgb(248, 216, 120), 
    sprWeaponIconsDischargeDash, 1, 
        " An electric barrier that can be charged by absorbing shots and weak enemies. Once charged, you can press FIRE to perform an invincible dash, even in the air.## The barrier can hold up to three charges, but it will still protect you even if it's fully charged.",
        "2#4.5#1#2");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///gain charge upon hitting enemy

if instance_exists(parent)
{
    if (parent.dischargeDashCharges &lt; 3)
    {
        parent.dischargeDashCharges++;
        animTimer = 0;
        var fx = instance_create(bboxGetXCenterObject(other), bboxGetYCenterObject(other), objSingleLoopEffect);
        fx.image_speed = 1/3;
        fx.sprite_index = spr4MICrit;
        playSFX(sfxEnkerCharge);
    }
    if antiRapidBuffer &lt;= 0
        global.ammo[playerID, global.weaponID[? objDischargeDash]] -= 1 / (global.energySaver + 1);
    else
        global.ammo[playerID, global.weaponID[? objDischargeDash]] -= 0.2 / (global.energySaver + 1);
    
    antiRapidBuffer = 4;
    
    //no item drops
    if !(object_is_ancestor(other.object_index, prtMiniBoss)
        || !other.killOverride)
    {
        with(other)
        {
            if itemDrop != 0
                event_perform_object(prtEntity, ev_other, ev_user10);
            else
                instance_create(bboxGetXCenter(), bboxGetYCenter(), objExplosion);
            
            y = -999;   //immediately despawns
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="17">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///don't deflect pls
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///the orbs are purely visual for simplicity
if !instance_exists(parent)
    exit;

//animations
var offImg = ((animTimer / 2) mod 16 &gt; 3);
var onImg = 2 + ((animTimer / 4) mod 4);
if onImg mod 1 &lt; 0.4
    onImg = 0;

//for loop that draws all of the sprites in a circle
var sid, v = 1, h = pi / 3;
for (var p = 0; p &lt; pi * 2; p += (pi * (2 / 3)))
{
    if parent.dischargeDashCharges &gt;= v
        sid = onImg;
    else
        sid = offImg;
    draw_sprite(sprite_index, sid, 
        floor(x + 0.5 + (sin(p + rotTimer) * rotRadius)), floor(y + 0.5 + (cos(p + rotTimer) * rotRadius)))
    if ((animTimer + v) mod 3 == 1) &amp;&amp; (we &gt; 0)
        draw_sprite(sprDischargeDashInbetween, animTimer / 6, 
            floor(x + (sin(p + rotTimer + h) * rotRadius)), 
            floor(y + (cos(p + rotTimer + h) * rotRadius)))
    v++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
